<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <title>Buraco ‚Äì Firebase</title>
    <link rel="manifest" href="manifest.webmanifest" />
    <meta name="theme-color" content="#020617" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="icon-32.png" />
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png" />
    <link rel="apple-touch-icon" sizes="192x192" href="icon-192.png" />

    <style>
      :root {
        --bg-main: #020617;
        --bg-panel-soft: rgba(15, 23, 42, 0.92);
        --accent: #22c55e;
        --accent-strong: #16a34a;
        --text-main: #e5e7eb;
        --text-muted: #9ca3af;
      }

      * {
        box-sizing: border-box;
        user-select: none;
        -webkit-tap-highlight-color: transparent; /* Remove piscar azul no toque */
      }

      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%; /* Fallback */
        height: 100dvh; /* Altura din√¢mica real do mobile */
        overflow: hidden; /* Trava scroll da p√°gina inteira */
        background: #020617;
        font-family: system-ui, -apple-system, sans-serif;
      }

      .app {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
      }

      /* TELA DE CONFIG (Scroll√°vel se necess√°rio) */
      #configSection {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        background: radial-gradient(circle at center, #064e3b 0%, #020617 100%);
        display: flex;
        flex-direction: column;
        justify-content: center;
      }

      /* ESTILOS DE CONFIGURA√á√ÉO */
      .section {
        background: rgba(15, 23, 42, 0.95);
        border-radius: 12px;
        padding: 20px;
        border: 1px solid #1f2937;
        max-width: 400px;
        margin: 0 auto;
        width: 100%;
      }
      .section h2 {
        margin-top: 0;
        color: #fff;
      }
      input,
      select {
        width: 100%;
        padding: 10px;
        margin-bottom: 10px;
        border-radius: 8px;
        border: 1px solid #4b5563;
        background: rgba(0, 0, 0, 0.3);
        color: white;
      }
      button {
        width: 100%;
        padding: 12px;
        border-radius: 99px;
        border: none;
        font-weight: bold;
        cursor: pointer;
        background: var(--accent-strong);
        color: white;
        margin-top: 5px;
      }

      /* ================= JOGO ================= */
      #gameSection {
        flex: 1;
        display: none; /* JS ativa display:flex */
        flex-direction: column;
        height: 100%;
        width: 100%;
        overflow: hidden;
        background: radial-gradient(circle at center, #15803d 0%, #14532d 100%);
      }

      .board {
        flex: 1;
        display: flex;
        flex-direction: column;
        position: relative;
        overflow: hidden; /* Garante que nada saia da mesa */
        padding-bottom: 0;
      }

      .board-center {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: center; /* desktop: pontos + monte/lixo bem no meio */
      }

      /* -- TOPO -- */
      .board-top {
        padding: 10px;
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        height: 50px; /* Altura fixa para n√£o variar */
        z-index: 20;
      }
      .current-player-chip {
        background: rgba(0, 0, 0, 0.5);
        padding: 4px 10px;
        border-radius: 20px;
        color: #fff;
        font-size: 12px;
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .current-dot {
        width: 8px;
        height: 8px;
        background: #4ade80;
        border-radius: 50%;
      }

      /* Mortos */
      .morto-area {
        display: flex;
        gap: 8px;
      }
      .morto-container {
        position: relative;
        width: 30px;
        height: 44px;
        opacity: 1;
      }

      .morto-label {
        position: absolute;
        bottom: -12px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 9px;
        color: #e5e7eb;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
      }

      .morto-container.used {
        opacity: 0;
      }
      .morto-card-back {
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 4px;
        background: #991b1b;
        border: 1px solid #fff;
      }
      .morto-card-back.offset {
        transform: translate(3px, -3px);
      }

      /* -- OPONENTES -- */
      .opponent-hand {
        position: absolute;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
        pointer-events: none;
        font-size: 10px;
        color: #e5e7eb;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
      }

      /* TOPO ‚Äì leque horizontal */
      .opponent-hand-top {
        top: 26px;
        left: 50%;
        transform: translateX(-50%);
      }

      /* LATERAIS ‚Äì ficam no meio da mesa */
      .opponent-hand-left,
      .opponent-hand-right {
        top: 50%;
        transform: translateY(-50%);
      }

      .opponent-hand-left {
        left: 10px;
        align-items: center;
      }

      .opponent-hand-right {
        right: 10px;
        align-items: center;
      }

      /* Nome + qtd de cartas */
      .opponent-label {
        font-size: 11px;
        opacity: 0.85;
        background: rgba(15, 23, 42, 0.9);
        padding: 2px 6px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.5);
      }

      .opponent-cards {
        display: flex;
        gap: 3px;
        min-width: 30px;
        min-height: 44px;
      }

      /* Verso das cartas dos oponentes */
      .opponent-card-back {
        width: 30px;
        height: 44px;
        border-radius: 6px;
        background: #7f1d1d;
        border: 1px solid #3d0a0a;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.7);
      }

      /* TOPO ‚Äì sobreposi√ß√£o leve, tipo leque */
      .opponent-hand-top .opponent-card-back {
        margin-left: -14px;
      }
      .opponent-hand-top .opponent-card-back:first-child {
        margin-left: 0;
      }

      /* LATERAIS ‚Äì coluna, levemente ‚Äújuntas‚Äù */
      .opponent-hand-left .opponent-cards,
      .opponent-hand-right .opponent-cards {
        flex-direction: column;
        align-items: center;
        min-width: 44px;
        min-height: 30px;
      }

      .opponent-hand-left .opponent-card-back,
      .opponent-hand-right .opponent-card-back {
        margin-top: -12px;
      }

      .opponent-hand-left .opponent-card-back:first-child,
      .opponent-hand-right .opponent-card-back:first-child {
        margin-top: 0;
      }

      /* Rota√ß√£o das laterais */
      .opponent-hand-left .opponent-card-back {
        transform: rotate(90deg);
        transform-origin: center center;
      }
      .opponent-hand-right .opponent-card-back {
        transform: rotate(-90deg);
        transform-origin: center center;
      }

      /* Laterais */
      .opponent-hand-left {
        top: 45%;
        left: 5px;
        transform: translateY(-50%);
      }
      .opponent-hand-left .opponent-card-back {
        transform: rotate(90deg);
        margin-bottom: -15px;
      }

      .opponent-hand-right {
        top: 45%;
        right: 5px;
        transform: translateY(-50%);
      }
      .opponent-hand-right .opponent-card-back {
        transform: rotate(-90deg);
        margin-bottom: -15px;
      }

      /* -- JOGOS BAIXADOS (√ÅREA DE MELDS) -- */
      .board-melds {
        flex: 0 0 auto;
        min-height: 60px;
        max-width: 760px;
        margin: 70px auto 4px;
        padding: 6px 10px;
        display: flex;
        gap: 20px;
        background: rgba(0, 0, 0, 0.15);
        border-radius: 8px;
        overflow: visible;
      }

      .board-melds .grow {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        background: rgba(15, 23, 42, 0.85);
        border-radius: 10px;
        padding: 6px 10px;
      }

      .board-melds .grow + .grow {
        padding-left: 16px !important;
        border-left: 1px dashed rgba(148, 163, 184, 0.5) !important;
      }

      .meld-title {
        display: flex;
        justify-content: space-between;
        font-size: 11px;
        color: #cbd5e1;
        margin-bottom: 4px;
      }

      .meld-container {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        align-content: flex-start;
        width: 100%;
        justify-content: flex-start;
        min-height: 52px;
      }

      /* Wrapper que ocupa o quadrado inteiro (evita o bug do painel vazio encolher) */
      .team-panel {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
      }

      /* Faz o container de melds preencher o resto do painel */
      .team-panel .meld-container {
        flex: 1;
        min-height: 52px;
      }

      /* Time do outro lado fica de ponta-cabe√ßa (quadrado inteiro) */
      .view-team0 #teamPanel2 {
        transform: rotate(180deg);
        transform-origin: center;
      }
      .view-team1 #teamPanel1 {
        transform: rotate(180deg);
        transform-origin: center;
      }

      .board-melds .grow {
        overflow: hidden;
      }

      .meld-line {
        max-width: 100%;
      }

      .meld-line {
        background: rgba(0, 0, 0, 0.45);
        border-radius: 6px;
        padding: 4px 6px 6px;
        display: flex;
        flex-direction: column;
        align-items: center;
        cursor: pointer;
        border: 1px solid transparent;
        flex: 0 1 auto;
        min-width: 140px;
      }

      .meld-line.selected-meld {
        border-color: #facc15;
        background: rgba(250, 204, 21, 0.2);
      }

      .meld-line-cards {
        display: flex;
        align-items: center;
        height: 42px;
      }

      .meld-meta {
        font-size: 10px;
        color: #e5e7eb;
        margin-top: 4px;
        text-align: center;
      }

      /* -- MEIO DA MESA (MONTE E LIXO) -- */
      .board-middle {
        display: flex;
        justify-content: center;
        gap: 30px;
        align-items: center;
        padding: 10px 0;
        flex-shrink: 0;
        z-index: 5;
      }

      .pile-area {
        display: flex;
        flex-direction: column;
        align-items: center;
        position: relative;
        cursor: pointer;
      }

      /* =========================
     MONTE (FIX): n√£o fica vermelho fixo
     ========================= */
      .pile-card {
        width: 55px;
        height: 80px;
        border-radius: 6px;
        background: transparent;
        border: 0;
        box-shadow: none;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: visible;
      }

      /* S√≥ o MONTE (n√£o o lixo): stack 50/50 em CSS */
      #drawStockBtn .pile-card::before,
      #drawStockBtn .pile-card::after {
        content: '';
        position: absolute;
        inset: 0;
        border-radius: 6px;
        border: 2px solid #fff;
        box-sizing: border-box;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
      }

      /* azul atr√°s */
      #drawStockBtn .pile-card::before {
        transform: translate(4px, -3px);
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 42%), radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0) 55%),
          repeating-linear-gradient(45deg, rgba(192, 192, 192, 0.22) 0 6px, rgba(0, 0, 0, 0) 6px 14px), repeating-linear-gradient(-45deg, rgba(0, 0, 0, 0.22) 0 7px, rgba(0, 0, 0, 0) 7px 16px), linear-gradient(135deg, #05071a, #1d4ed8);
      }

      /* vermelho na frente */
      #drawStockBtn .pile-card::after {
        transform: translate(0px, 0px);
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 42%), radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0) 55%),
          repeating-linear-gradient(45deg, rgba(255, 215, 0, 0.22) 0 6px, rgba(0, 0, 0, 0) 6px 14px), repeating-linear-gradient(-45deg, rgba(0, 0, 0, 0.22) 0 7px, rgba(0, 0, 0, 0) 7px 16px), linear-gradient(135deg, #140007, #b91c1c);
      }

      .pile-card.discard-pile {
        background: transparent;
        border: 2px dashed rgba(255, 255, 255, 0.4);
        box-shadow: none;
      }

      .discard-face {
        width: 100%;
        height: 100%;
        background: #f3f4f6;
        border-radius: 4px;
        color: #000;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        padding: 2px;
        font-weight: bold;
        font-size: 12px;
      }

      .pile-info {
        font-size: 10px;
        color: #fff;
        background: rgba(0, 0, 0, 0.7);
        padding: 2px 6px;
        border-radius: 10px;
        margin-top: -8px;
        z-index: 10;
      }

      /* -- √ÅREA DO JOGADOR (RODAP√â) -- */
      .player-interface {
        background: linear-gradient(to top, rgba(2, 6, 23, 0.95) 0%, rgba(2, 6, 23, 0.8) 60%, transparent 100%);
        padding: 5px 10px 10px 10px;
        display: flex;
        flex-direction: column;
        gap: 5px;
        z-index: 50;
        width: 100%;
        flex-shrink: 0;
      }

      #message {
        text-align: center;
        font-size: 11px;
        color: #facc15;
        font-weight: bold;
        height: 15px;
        text-shadow: 0 1px 2px black;
      }

      .player-actions {
        display: flex;
        justify-content: center;
        gap: 8px;
      }

      .player-actions button {
        width: auto;
        padding: 8px 12px;
        font-size: 11px;
        margin: 0;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      #meldBtn {
        background: #059669;
      }

      #discardBtn {
        background: #be123c;
      }

      #takeDeadBtn {
        background: #4f46e5;
      }

      #endGameBtn {
        background: #333;
        padding: 8px;
      }

      /* M√ÉO DO JOGADOR - LEQUE */
      .hand-container {
        display: flex;
        justify-content: center;
        overflow-x: auto;
        padding: 15px 10px 5px 10px;
        min-height: 90px;
        flex-shrink: 0;
      }

      .cards-row {
        display: flex;
        align-items: flex-end;
        padding-right: 20px;
      }

      /* CARTA PADR√ÉO */
      .carta {
        width: 60px;
        height: 90px;
        background: #fff;
        border-radius: 5px;
        border: 1px solid #000;
        position: relative;
        flex-shrink: 0;
        cursor: pointer;
        box-shadow: -1px 1px 4px rgba(0, 0, 0, 0.3);
        margin-right: -30px;
        transition: transform 0.1s, margin-right 0.1s;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        padding: 2px 4px;
        font-size: 14px;
        font-weight: bold;
      }

      .carta:last-child {
        margin-right: 0;
      }

      #handContainer .carta:hover,
      #handContainer .carta.selected {
        /* transform: translateY(-15px); */
        margin-right: 0;
        z-index: 100;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
      }

      .carta.selected {
        border: 2px solid #facc15;
      }

      /* ==========================
     ANIMA√á√ÉO: carta voadora
     ========================== */
      .fly-card {
        position: fixed;
        left: 0;
        top: 0;
        margin: 0 !important;
        z-index: 9999;
        pointer-events: none;
        transform-origin: top left;
        will-change: transform, opacity;
      }

      /* costas por cor (FINDOM + borda branca) */
      .back-red {
        border: 2px solid #fff !important;
        box-sizing: border-box;

        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 42%), radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0) 55%),
          repeating-linear-gradient(45deg, rgba(255, 215, 0, 0.22) 0 6px, rgba(0, 0, 0, 0) 6px 14px), repeating-linear-gradient(-45deg, rgba(0, 0, 0, 0.22) 0 7px, rgba(0, 0, 0, 0) 7px 16px), linear-gradient(135deg, #140007, #b91c1c) !important;
      }

      .back-blue {
        border: 2px solid #fff !important;
        box-sizing: border-box;

        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 42%), radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0) 55%),
          repeating-linear-gradient(45deg, rgba(192, 192, 192, 0.22) 0 6px, rgba(0, 0, 0, 0) 6px 14px), repeating-linear-gradient(-45deg, rgba(0, 0, 0, 0.22) 0 7px, rgba(0, 0, 0, 0) 7px 16px), linear-gradient(135deg, #05071a, #1d4ed8) !important;
      }

      /* fly-card de costas usa o MESMO visual; e respeita blue se existir */
      .fly-card.back {
        border: 2px solid #fff !important;
        box-sizing: border-box;
      }
      .fly-card.back.back-red {
        background: unset;
      } /* s√≥ pra n√£o ‚Äúprender‚Äù */
      .fly-card.back.back-blue {
        background: unset;
      }
      .fly-card.back {
        /* default: vermelho findom */
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 42%), radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0) 55%),
          repeating-linear-gradient(45deg, rgba(255, 215, 0, 0.22) 0 6px, rgba(0, 0, 0, 0) 6px 14px), repeating-linear-gradient(-45deg, rgba(0, 0, 0, 0.22) 0 7px, rgba(0, 0, 0, 0) 7px 16px), linear-gradient(135deg, #140007, #b91c1c) !important;
      }
      .fly-card.back.back-blue {
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 42%), radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0) 55%),
          repeating-linear-gradient(45deg, rgba(192, 192, 192, 0.22) 0 6px, rgba(0, 0, 0, 0) 6px 14px), repeating-linear-gradient(-45deg, rgba(0, 0, 0, 0.22) 0 7px, rgba(0, 0, 0, 0) 7px 16px), linear-gradient(135deg, #05071a, #1d4ed8) !important;
      }

      /* IMPORTANT√çSSIMO: oponente/morto N√ÉO podem sobrescrever o back */
      .opponent-card-back.back-red,
      .opponent-card-back.back-blue {
        border: 2px solid #fff !important; /* volta borda branca */
        box-sizing: border-box !important;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.7);
      }
      .opponent-card-back.back-red {
        /* reaplica o mesmo tema do .back-red */
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 42%), radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0) 55%),
          repeating-linear-gradient(45deg, rgba(255, 215, 0, 0.22) 0 6px, rgba(0, 0, 0, 0) 6px 14px), repeating-linear-gradient(-45deg, rgba(0, 0, 0, 0.22) 0 7px, rgba(0, 0, 0, 0) 7px 16px), linear-gradient(135deg, #140007, #b91c1c) !important;
      }
      .opponent-card-back.back-blue {
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 42%), radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0) 55%),
          repeating-linear-gradient(45deg, rgba(192, 192, 192, 0.22) 0 6px, rgba(0, 0, 0, 0) 6px 14px), repeating-linear-gradient(-45deg, rgba(0, 0, 0, 0.22) 0 7px, rgba(0, 0, 0, 0) 7px 16px), linear-gradient(135deg, #05071a, #1d4ed8) !important;
      }

      .morto-card-back.back-red {
        border: 1px solid #fff !important;
        box-sizing: border-box !important;
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 42%), radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0) 55%),
          repeating-linear-gradient(45deg, rgba(255, 215, 0, 0.22) 0 6px, rgba(0, 0, 0, 0) 6px 14px), repeating-linear-gradient(-45deg, rgba(0, 0, 0, 0.22) 0 7px, rgba(0, 0, 0, 0) 7px 16px), linear-gradient(135deg, #140007, #b91c1c) !important;
      }
      .morto-card-back.back-blue {
        border: 1px solid #fff !important;
        box-sizing: border-box !important;
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 42%), radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0) 55%),
          repeating-linear-gradient(45deg, rgba(192, 192, 192, 0.22) 0 6px, rgba(0, 0, 0, 0) 6px 14px), repeating-linear-gradient(-45deg, rgba(0, 0, 0, 0.22) 0 7px, rgba(0, 0, 0, 0) 7px 16px), linear-gradient(135deg, #05071a, #1d4ed8) !important;
      }

      /* fly-card de costas: s√≥ esconde face */
      .fly-card.back * {
        visibility: hidden;
      }

      /* ===== IMPACTO + FA√çSCAS ===== */
      .impact-ring {
        position: fixed;
        left: 0;
        top: 0;
        width: 10px;
        height: 10px;
        border-radius: 999px;
        border: 2px solid rgba(250, 204, 21, 0.95);
        box-shadow: 0 0 18px rgba(250, 204, 21, 0.6);
        pointer-events: none;
        z-index: 10000;
        transform: translate(-50%, -50%) scale(0.2);
        opacity: 0.95;
      }

      .spark {
        position: fixed;
        left: 0;
        top: 0;
        width: 6px;
        height: 2px;
        border-radius: 999px;
        background: rgba(250, 204, 21, 1);
        box-shadow: 0 0 10px rgba(250, 204, 21, 0.85);
        pointer-events: none;
        z-index: 10000;
        transform: translate(-50%, -50%);
        opacity: 1;
      }

      .card-impact {
        animation: cardImpact 160ms ease-out;
      }

      @keyframes cardImpact {
        0% {
          transform: translateY(0px) scale(1);
        }
        45% {
          transform: translateY(2px) scale(0.985);
        }
        100% {
          transform: translateY(0px) scale(1);
        }
      }

      /* Destaque tempor√°rio: carta comprada */
      .carta.just-bought {
        border: 2px solid #facc15 !important;
        box-shadow: 0 0 0 4px rgba(250, 204, 21, 0.45), 0 10px 22px rgba(0, 0, 0, 0.65) !important;
        animation: justBoughtGlow 1.2s ease-out forwards;
        z-index: 999;
      }

      @keyframes justBoughtGlow {
        0% {
          transform: translateY(-18px);
          box-shadow: 0 0 0 8px rgba(250, 204, 21, 0.65), 0 14px 28px rgba(0, 0, 0, 0.75);
        }
        100% {
          transform: translateY(0px);
          box-shadow: 0 0 0 0px rgba(250, 204, 21, 0), 0 10px 22px rgba(0, 0, 0, 0.35);
        }
      }

      .hearts,
      .diamonds {
        color: #dc2626;
      }

      .spades,
      .clubs,
      .joker-card {
        color: #000;
      }

      .carta-icone {
        font-size: 20px;
        align-self: flex-end;
        line-height: 1;
      }

      /* MINI CARTA (NA MESA) */
      .carta.mini {
        width: 38px;
        height: 50px;
        margin-right: -14px;
        margin-bottom: 0;
        font-size: 10px;
        padding: 1px;
      }

      .carta.mini .carta-icone {
        font-size: 12px;
      }

      .carta.mini.canastra-fechada {
        transform: rotate(90deg);
        margin-right: -8px;
        margin-bottom: -8px;
      }

      /* PLACAR OVERLAY */
      #scoreSection {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.95);
        z-index: 200;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      @media (max-width: 768px), (max-height: 500px) {
        body {
          font-size: 12px;
        }

        .board {
          overflow-y: auto;
          overflow-x: hidden;
          display: flex;
          flex-direction: column;
        }

        .board-center {
          flex: 1;
          justify-content: space-between;
          padding: 2px 0;
        }

        .board-top {
          padding: 3px 5px;
          height: 36px;
        }

        .opponent-hand-top {
          top: 2px;
        }

        .meld-title {
          font-size: 9px;
        }

        .meld-line {
          min-width: 110px;
          padding: 2px 3px 3px;
        }

        .meld-line-cards {
          height: 28px;
        }

        .carta.mini {
          width: 32px;
          height: 40px;
          margin-right: -9px;
          font-size: 8.5px;
        }

        .board-middle {
          gap: 10px;
          padding: 0;
          margin-top: 4px;
        }

        .pile-card {
          width: 38px;
          height: 54px;
        }

        .pile-info {
          font-size: 9px;
        }

        .hand-container {
          padding: 4px 2px 2px 2px;
          min-height: 60px;
          flex-shrink: 0;
        }

        .opponent-cards {
          gap: 1px;
        }

        .carta {
          width: 42px;
          height: 62px;
          margin-right: -18px;
          font-size: 10px;
        }

        .carta-icone {
          font-size: 13px;
        }

        .player-interface {
          padding: 2px 4px 4px 4px;
          gap: 2px;
        }

        #message {
          font-size: 10px;
          height: 12px;
        }

        .player-actions {
          gap: 4px;
        }

        .player-actions button {
          padding: 4px 6px;
          font-size: 9px;
        }

        #scoreSection .section {
          width: 94%;
          max-width: 380px;
        }
      }

      /* ===========================
   MORTOS (FIX CSS ONLY)
   Morto 1 = vermelho / Morto 2 = azul
   cole no FINAL do CSS
   =========================== */

      #mortoSlot0 .morto-card-back {
        border: 1px solid #fff !important;
        box-sizing: border-box !important;
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 42%), radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0) 55%),
          repeating-linear-gradient(45deg, rgba(255, 215, 0, 0.22) 0 6px, rgba(0, 0, 0, 0) 6px 14px), repeating-linear-gradient(-45deg, rgba(0, 0, 0, 0.22) 0 7px, rgba(0, 0, 0, 0) 7px 16px), linear-gradient(135deg, #140007, #b91c1c) !important;
      }

      #mortoSlot1 .morto-card-back {
        border: 1px solid #fff !important;
        box-sizing: border-box !important;
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 42%), radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0) 55%),
          repeating-linear-gradient(45deg, rgba(192, 192, 192, 0.22) 0 6px, rgba(0, 0, 0, 0) 6px 14px), repeating-linear-gradient(-45deg, rgba(0, 0, 0, 0.22) 0 7px, rgba(0, 0, 0, 0) 7px 16px), linear-gradient(135deg, #05071a, #1d4ed8) !important;
      }

      /* opcional: d√° uma pequena suavizada */
      .meld-line-cards {
        transition: transform 0.15s ease;
      }

      /* ===== Tags de canastra (voc√™ j√° renderiza, faltava o CSS) ===== */
      .meld-tag {
        display: inline-block;
        font-size: 9px;
        padding: 1px 6px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.25);
        margin-left: 4px;
        line-height: 1.3;
      }

      .meld-tag.suja {
        background: rgba(239, 68, 68, 0.18);
        color: #fecaca;
        border-color: rgba(239, 68, 68, 0.35);
      }
      .meld-tag.limpa {
        background: rgba(34, 197, 94, 0.18);
        color: #bbf7d0;
        border-color: rgba(34, 197, 94, 0.35);
      }
      .meld-tag.real {
        background: rgba(250, 204, 21, 0.18);
        color: #fde68a;
        border-color: rgba(250, 204, 21, 0.35);
      }
      .meld-tag.asas {
        background: rgba(99, 102, 241, 0.18);
        color: #c7d2fe;
        border-color: rgba(99, 102, 241, 0.35);
      }

      /* ===== Bot√£o mover 2/Joker ===== */
      #moveWildBtn {
        background: #0ea5e9;
      }
      #moveWildBtn:disabled {
        opacity: 0.5;
      }

      /* ===== UI de sele√ß√£o do 2/Joker na mesa ===== */
      .carta.mini.wild-pickable {
        cursor: pointer;
        outline: 1px dashed rgba(250, 204, 21, 0.6);
        outline-offset: 1px;
      }
      .carta.mini.wild-picked {
        border: 2px solid #facc15 !important;
        box-shadow: 0 0 0 3px rgba(250, 204, 21, 0.35) !important;
        transform: translateY(-2px);
      }
    </style>
  </head>
  <body>
    <div class="app">
      <div id="configSection">
        <div class="section">
          <div class="section-header">
            <h2>Buraco Alpha</h2>
            <small>Configura√ß√£o da sala</small>
          </div>
          <div style="margin-top: 15px; display: flex; flex-direction: column; gap: 10px">
            <label>
              Modo
              <select id="modeSelect">
                <option value="1x1">1x1</option>
                <option value="2x2">2x2</option>
                <option value="1x2">1x2</option>
                <option value="1x1_duploMorto">1x1 Humilha√ß√£o</option>
              </select>
            </label>
            <label>
              Regra
              <select id="variantSelect">
                <option value="aberto">Aberto</option>
                <option value="fechado">Fechado</option>
              </select>
            </label>
            <label>
              Sou
              <select id="localPlayerSelect">
                <option value="0">Jogador 1</option>
                <option value="1">Jogador 2</option>
                <option value="2">Jogador 3</option>
                <option value="3">Jogador 4</option>
              </select>
            </label>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px">
              <input id="p1Name" value="Jogador 1" placeholder="Nome J1" />
              <input id="p2Name" value="Jogador 2" placeholder="Nome J2" />
              <input id="p3Name" value="Jogador 3" placeholder="Nome J3" />
              <input id="p4Name" value="Jogador 4" placeholder="Nome J4" />
            </div>

            <button id="startBtn" style="margin-top: 10px">INICIAR JOGO</button>
            <small style="text-align: center; color: #666">Use o mesmo ID na URL para conectar: ?game=sala1</small>
          </div>
        </div>
      </div>

      <div id="gameSection">
        <div class="board">
          <div class="board-top">
            <div>
              <span class="current-player-chip">
                <span class="current-dot"></span>
                <span id="currentPlayerLabel">...</span>
              </span>
              <span id="turnTimerLabel" style="margin-left: 5px; font-size: 11px; color: #facc15"></span>
            </div>

            <div class="morto-area">
              <div id="mortoSlot0" class="morto-container" title="Morto Time 1">
                <div class="morto-card-back"></div>
                <div class="morto-card-back offset"></div>
                <span class="morto-label">Morto 1</span>
              </div>
              <div id="mortoSlot1" class="morto-container" title="Morto Time 2">
                <div class="morto-card-back"></div>
                <div class="morto-card-back offset"></div>
                <span class="morto-label">Morto 2</span>
              </div>
            </div>
          </div>

          <!-- Oponentes (continuam absolutos por cima da mesa) -->
          <div id="opponentTop" class="opponent-hand opponent-hand-top"></div>
          <div id="opponentLeft" class="opponent-hand opponent-hand-left"></div>
          <div id="opponentRight" class="opponent-hand opponent-hand-right"></div>

          <!-- Centro da mesa: pontos + monte/lixo -->
          <div class="board-center">
            <div class="board-melds">
              <div class="grow">
                <div class="team-panel" id="teamPanel1">
                  <div class="meld-title">
                    <span>Time 1 Pts:</span>
                    <strong id="scoreTeam1">0</strong>
                  </div>
                  <div id="meldsP1" class="meld-container"></div>
                </div>
              </div>

              <div class="grow">
                <div class="team-panel" id="teamPanel2">
                  <div class="meld-title">
                    <span>Time 2 Pts:</span>
                    <strong id="scoreTeam2">0</strong>
                  </div>
                  <div id="meldsP2" class="meld-container"></div>
                </div>
              </div>
            </div>

            <div class="board-middle">
              <div class="pile-area" id="drawStockBtn">
                <div class="pile-card">
                  <div class="pile-card-inner"></div>
                </div>
                <div class="pile-info">
                  Monte (
                  <span id="stockCount">0</span>
                  )
                </div>
              </div>

              <div class="pile-area" id="drawDiscardBtn">
                <div class="pile-card discard-pile">
                  <div id="discardFace" class="discard-face">
                    <div id="discardFaceTop"></div>
                    <div id="discardFaceBottom"></div>
                  </div>
                </div>
                <div class="pile-info">
                  Lixo (
                  <span id="discardCount">0</span>
                  )
                </div>
                <span id="discardTop" style="display: none"></span>
              </div>
            </div>
          </div>

          <!-- √Årea do jogador -->
          <div class="player-interface">
            <div id="message"></div>

            <div class="player-actions">
              <button id="meldBtn">‚¨áÔ∏è Baixar</button>
              <button id="moveWildBtn">‚ÜîÔ∏è Mover 2/Joker</button>
              <button id="discardBtn">üóëÔ∏è Descartar</button>
              <button id="takeDeadBtn">üíÄ Morto</button>
              <button id="endGameBtn" style="background: #333; font-size: 10px; padding: 8px">‚ùå</button>
            </div>

            <div style="position: absolute; right: 10px; top: 10px; font-size: 10px; color: #aaa">
              <span id="handCountLabel"></span>
            </div>

            <div id="handContainer" class="hand-container">
              <div class="cards-row"></div>
            </div>
          </div>
        </div>
      </div>
      <div id="scoreSection" style="display: none">
        <div class="section" style="width: 90%; max-width: 500px">
          <h2>Fim de Jogo</h2>
          <div id="scoreBoard"></div>
          <button id="closeScoreBtn" style="width: 100%; margin-top: 10px">Fechar</button>
        </div>
      </div>
    </div>

    <script type="module">
      import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js';
      import { getFirestore, doc, setDoc, updateDoc, onSnapshot, deleteDoc } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js';

      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          // SW opcional
        });
      }

      const firebaseConfig = {
        apiKey: 'AIzaSyBHvYOK7pWkikA9x5AjrVjuuSmopHisGik',
        authDomain: 'buraco-27cb3.firebaseapp.com',
        projectId: 'buraco-27cb3',
        storageBucket: 'buraco-27cb3.firebasestorage.app',
        messagingSenderId: '793904091112',
        appId: '1:793904091112:web:3e9f299f5603ee4b6a5e5d',
        measurementId: 'G-Q0RRR9714T',
      };

      const app = initializeApp(firebaseConfig);
      const db = getFirestore(app);

      const urlParams = new URLSearchParams(window.location.search);
      const gameId = urlParams.get('game') || 'teste';
      let myPlayerIndex = parseInt(urlParams.get('player') || '0', 10);

      const gameRef = doc(db, 'buracoGames', gameId);

      const SUITS = ['‚ô£', '‚ô¶', '‚ô•', '‚ô†'];
      const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
      const RANKS_SEQ = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
      const RANKS_SEQ_LOW = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

      const DEAD_CHUNK_SIZE = 11;

      let state = null;
      let selectedHandIndexes = new Set();
      let turnTimerId = null;
      let turnTimerRemaining = 0;
      let selectedMeldTarget = null;
      let lastMyTurn = false; // NOVO: pra saber quando virou a SUA vez
      let lastSeenActionId = null;
      let ignoreOwnActionId = null;

      let movingWild = null;
      // { fromTeamId, fromMeldIndex, fromCardIndex, card }

      window.getState = () => state;
      window.setState = (s) => ((state = s), renderAll());

      // ==========================
      // üîÑ VIEW ORIENTATION (fixo por cliente)
      // Cada cliente v√™ APENAS o pr√≥prio time "de p√©".
      // N√ÉO depende de quem est√° jogando no momento.

      function buildRankIndex(order) {
        const m = {};
        order.forEach((r, i) => (m[r] = i));
        return m;
      }
      const IDX_HIGH = buildRankIndex(RANKS_SEQ);
      const IDX_LOW = buildRankIndex(RANKS_SEQ_LOW);

      function missingRankBetween(a, b) {
        // retorna o rank que falta quando a e b t√™m diferen√ßa 2 (ex.: 6 e 8 -> 7)
        const ah = IDX_HIGH[a],
          bh = IDX_HIGH[b];
        if (ah != null && bh === ah + 2) return RANKS_SEQ[ah + 1];

        const al = IDX_LOW[a],
          bl = IDX_LOW[b];
        if (al != null && bl === al + 2) return RANKS_SEQ_LOW[al + 1];

        return null;
      }

      // empurra o coringa (2/Joker) pra uma ponta sem quebrar o jogo
      function pushWildToEdge(meld, wildIdx) {
        const wild = meld[wildIdx];

        // tenta direita
        let cand = meld.slice();
        cand.splice(wildIdx, 1);
        cand.push(wild);
        if (isValidSequenceMeld(cand)) return cand;

        // tenta esquerda
        cand = meld.slice();
        cand.splice(wildIdx, 1);
        cand.unshift(wild);
        if (isValidSequenceMeld(cand)) return cand;

        return null;
      }

      // caso cl√°ssico: 5,6,2,8 + baixa 7 => 5,6,7,8 e 2 vai pra ponta
      function autoSwapWildWhenFillingGap(meld) {
        if (!meld || meld.length < 4) return false;

        // acha 1 wild "de verdade" (2 ou joker) no meio
        const wIdx = meld.findIndex((c, i) => (c?.joker || c?.rank === '2') && isWildcard(c, meld) && i > 0 && i < meld.length - 1);
        if (wIdx === -1) return false;

        const left = meld[wIdx - 1];
        const right = meld[wIdx + 1];
        if (!left || !right) return false;
        if (left.joker || right.joker) return false;
        if (left.suit !== right.suit) return false;

        const needed = missingRankBetween(left.rank, right.rank);
        if (!needed) return false;

        // existe a carta natural needed no meld? (porque o jogador acabou de baixar)
        const naturalIdx = meld.findIndex((c, i) => i !== wIdx && !c.joker && c.rank === needed && c.suit === left.suit);
        if (naturalIdx === -1) return false;

        const wild = meld[wIdx];
        const natural = meld[naturalIdx];

        // ‚úÖ o 2 estava sendo usado como coringa; fixa isso (n√£o deixa virar "natural" por posi√ß√£o)
        if (!wild.joker && wild.rank === '2') wild.forceWild = true;

        // troca: natural entra no lugar do wild
        meld[wIdx] = natural;

        // remove a natural da posi√ß√£o antiga
        meld.splice(naturalIdx, 1);

        // recoloca o wild e tenta empurrar pra ponta
        const insertAt = naturalIdx < wIdx ? wIdx - 1 : wIdx; // ajuste de √≠ndice por causa do splice
        meld.splice(insertAt, 0, wild);

        const pushed = pushWildToEdge(meld, meld.indexOf(wild));
        if (pushed) {
          meld.splice(0, meld.length, ...pushed);
        }

        return true;
      }

      // ==========================
      function applyViewTeamClass() {
        document.body.classList.remove('view-team0', 'view-team1');
        if (!state?.players?.length) return;
        const me = state.players[myPlayerIndex];
        if (!me) return;
        document.body.classList.add(me.teamId === 0 ? 'view-team0' : 'view-team1');
      }

      // ==========================
      // üîä SFX CANASTRA (SEM BUGAR SEU C√ìDIGO)
      // Toca quando um meld vira canastra (simple -> limpa/suja/real/asas)
      // Funciona local+remoto via onSnapshot diff e N√ÉO toca na entrada (prime)
      // ==========================

      // ==========================
      // üîä SFX CANASTRA (MP3 do seu projeto)
      // ==========================
      let audioUnlocked = false;

      const CANASTRA_SFX = {
        suja: new Audio('assets/sfx/canastra-suja.mp3'),
        limpa: new Audio('assets/sfx/canastra-limpa.mp3'),
        real: new Audio('assets/sfx/canastra-real.mp3'),
        asas: new Audio('assets/sfx/canastra-as-a-as.mp3'),
      };

      Object.values(CANASTRA_SFX).forEach((a) => {
        a.preload = 'auto';
        a.volume = 0.9;
      });

      function unlockAudio() {
        if (audioUnlocked) return;
        audioUnlocked = true;

        // "prime" silencioso (alguns browsers exigem gesto antes de tocar)
        for (const a of Object.values(CANASTRA_SFX)) {
          try {
            a.pause();
            a.currentTime = 0;
            a.play()
              .then(() => {
                a.pause();
                a.currentTime = 0;
              })
              .catch(() => {});
          } catch (e) {}
        }
      }

      function isMovableTwoOrJoker(card) {
        if (!card) return false;
        return !!card.joker || card.rank === '2';
      }

      function meldKey(teamId, meldIdx) {
        return `${teamId}:${meldIdx}`;
      }

      function parseMeldKey(key) {
        if (!key) return null;
        const [t, m] = key.split(':');
        const teamId = parseInt(t, 10);
        const meldIdx = parseInt(m, 10);
        if (Number.isNaN(teamId) || Number.isNaN(meldIdx)) return null;
        return { teamId, meldIdx };
      }

      function miniCardElByMeld(teamId, meldIdx, cardIdx) {
        const key = meldKey(teamId, meldIdx);
        return document.querySelector(`.meld-line[data-meld-key="${key}"] .carta.mini[data-card-index="${cardIdx}"]`);
      }

      function meldCardsRect(teamId, meldIdx) {
        const key = meldKey(teamId, meldIdx);
        const meldEl = document.querySelector(`.meld-line[data-meld-key="${key}"]`);
        const row = meldEl ? meldEl.querySelector('.meld-line-cards') : null;
        const r = row ? row.getBoundingClientRect() : null;
        if (!r) return null;
        // um ‚Äúret√¢ngulo pequeno‚Äù no meio da linha, pra animar de origem
        return { left: r.left + r.width * 0.5 - 14, top: r.top + 4, width: 28, height: 40 };
      }

      function clearMovingWild(msg = null) {
        movingWild = null;
        if (msg) showMessage(msg);
        renderMelds();
        // bot√£o liga/desliga via renderAll
        renderAll();
      }

      function pickWildFromMeld(teamId, meldIdx, cardIdx) {
        if (!state || state.finished) return;

        const myTurn = state.currentPlayer === myPlayerIndex;
        if (!myTurn || !state.hasDrawnThisTurn) {
          showMessage('S√≥ d√° pra mover depois de comprar e na sua vez.');
          return;
        }

        const me = state.players[myPlayerIndex];
        if (teamId !== me.teamId) {
          showMessage('Voc√™ s√≥ mexe nos jogos do SEU time.');
          return;
        }

        const meld = state.teams?.[teamId]?.melds?.[meldIdx];
        if (!meld || !meld[cardIdx]) return;

        const card = meld[cardIdx];
        if (!isMovableTwoOrJoker(card)) {
          showMessage('S√≥ pode mover JOKER ou 2.');
          return;
        }

        // toggle: clicou no mesmo -> cancela
        if (movingWild && movingWild.fromTeamId === teamId && movingWild.fromMeldIndex === meldIdx && movingWild.fromCardIndex === cardIdx) {
          clearMovingWild('Movimento cancelado.');
          return;
        }

        ensureCardId(card);
        movingWild = {
          fromTeamId: teamId,
          fromMeldIndex: meldIdx,
          fromCardIndex: cardIdx,
          card: packCard(card),
        };

        showMessage('Clique em "Mover 2/Joker". (Selecionar destino √© opcional)');

        renderMelds();
        renderAll();
      }

      async function movePickedWildToSelectedMeld() {
        if (!state || state.finished) return;
        if (!ensureMyTurn()) return;
        if (!state.hasDrawnThisTurn) {
          showMessage('Compre primeiro.');
          return;
        }

        if (!movingWild) {
          showMessage('Clique num 2/JOKER no jogo pra selecionar.');
          return;
        }

        const me = state.players[myPlayerIndex];
        const myTeamId = me.teamId;

        const destParsed = parseMeldKey(selectedMeldTarget) || { teamId: movingWild.fromTeamId, meldIdx: movingWild.fromMeldIndex };

        if (!destParsed || destParsed.teamId !== myTeamId) {
          showMessage('Selecione um jogo DESTINO do seu time.');
          return;
        }

        const { teamId: toTeamId, meldIdx: toMeldIdx } = destParsed;

        const fromTeamId = movingWild.fromTeamId;
        const fromMeldIdx = movingWild.fromMeldIndex;
        const fromCardIdx = movingWild.fromCardIndex;

        if (fromTeamId !== myTeamId) {
          showMessage('Origem n√£o √© do seu time (bug de sele√ß√£o).');
          clearMovingWild();
          return;
        }

        const team = state.teams[myTeamId];
        const fromMeld = team?.melds?.[fromMeldIdx];
        const toMeld = team?.melds?.[toMeldIdx];

        if (!fromMeld || !toMeld) {
          showMessage('Jogo origem/destino inv√°lido.');
          clearMovingWild();
          return;
        }

        // pega a carta (por √≠ndice e, se tiver id, re-localiza por id pra evitar √≠ndice "velho")
        const rawCard = fromMeld[fromCardIdx];
        if (!rawCard || !isMovableTwoOrJoker(rawCard)) {
          showMessage('Essa carta n√£o existe mais no jogo origem.');
          clearMovingWild();
          return;
        }
        ensureCardId(rawCard);
        const cardId = rawCard.id;
        const actualFromIdx = fromMeld.findIndex((c) => c && c.id === cardId);
        const fromIdx = actualFromIdx >= 0 ? actualFromIdx : fromCardIdx;
        const card = fromMeld[fromIdx];

        const sameMeld = fromMeldIdx === toMeldIdx;

        // ===== valida√ß√£o (SIMULA, sem mexer no state) =====
        if (sameMeld) {
          // üîÅ toggle simples: se t√° no fim -> vai pro come√ßo; sen√£o -> vai pro fim
          const targetIndex = fromIdx === fromMeld.length - 1 ? 0 : fromMeld.length - 1;

          const after = fromMeld.slice();
          const [moved] = after.splice(fromIdx, 1);
          if (targetIndex === 0) after.unshift(moved);
          else after.push(moved);

          if (after.length < 3) {
            showMessage('N√£o pode quebrar o jogo (m√≠nimo 3 cartas).');
            return;
          }
          if (!isValidSequenceMeld(after)) {
            showMessage('Mover assim deixa o jogo inv√°lido.');
            return;
          }
        } else {
          const fromAfter = fromMeld.slice();
          fromAfter.splice(fromIdx, 1);

          const toAfter = toMeld.slice();
          toAfter.push(card);

          if (fromAfter.length < 3) {
            showMessage('N√£o pode quebrar o jogo origem (m√≠nimo 3 cartas).');
            return;
          }
          if (!isValidSequenceMeld(fromAfter)) {
            showMessage('Remover isso quebra o jogo origem.');
            return;
          }
          if (!isValidSequenceMeld(toAfter)) {
            showMessage('Mover pra esse destino deixa o jogo inv√°lido.');
            return;
          }
        }

        // ===== anima√ß√£o =====
        // origem no DOM
        const fromEl = miniCardElByMeld(myTeamId, fromMeldIdx, fromIdx);
        const fromRect = fromEl ? getRect(fromEl) : meldCardsRect(myTeamId, fromMeldIdx);

        // destino no DOM
        const keyTo = meldKey(myTeamId, toMeldIdx);

        let toRect = null;
        if (sameMeld) {
          const targetIndex = fromIdx === fromMeld.length - 1 ? 0 : fromMeld.length - 1;
          if (targetIndex === 0) {
            const meldEl = meldElByKey(keyTo);
            const row = meldEl ? meldEl.querySelector('.meld-line-cards') : null;
            const r = row ? row.getBoundingClientRect() : null;
            toRect = r ? { left: r.left + 4, top: r.top + 4, width: 28, height: 40 } : meldCardsRect(myTeamId, toMeldIdx);
          } else {
            const baseDrop = meldDropRect(keyTo, 0);
            toRect = baseDrop || meldCardsRect(myTeamId, toMeldIdx);
          }
        } else {
          const baseDrop = meldDropRect(keyTo, 0);
          toRect = baseDrop || meldCardsRect(myTeamId, toMeldIdx);
        }

        if (fromEl) fromEl.style.visibility = 'hidden';
        if (fromRect && toRect) {
          await flyRectToRect(card, fromRect, toRect, 'front');
          impactAtRect(toRect);
        }
        if (fromEl) fromEl.style.visibility = '';

        // ===== aplica no state (1x) =====
        if (sameMeld) {
          const targetIndex = fromIdx === fromMeld.length - 1 ? 0 : fromMeld.length - 1;
          const [moved] = fromMeld.splice(fromIdx, 1);
          if (targetIndex === 0) fromMeld.unshift(moved);
          else fromMeld.push(moved);
          // N√ÉO normalize aqui, sen√£o ele desfaz tua inten√ß√£o e o 2 muda de papel sozinho
        } else {
          const [moved] = fromMeld.splice(fromIdx, 1);
          toMeld.push(moved);
          normalizeMeldOrder(fromMeld);
          normalizeMeldOrder(toMeld);
        }

        // limpa sele√ß√£o + avisa
        const actionCard = packCard(card);
        const actionId = newActionId();

        state.lastAction = {
          id: actionId,
          type: 'meldMoveWild',
          playerId: myPlayerIndex,
          teamId: myTeamId,
          fromMeldIndex: fromMeldIdx,
          toMeldIndex: toMeldIdx,
          card: actionCard,
          ts: Date.now(),
        };
        ignoreOwnActionId = actionId;

        movingWild = null;
        // deixa o destino selecionado (pra facilitar "voltar" sem clicar tudo de novo)
        // selectedMeldTarget = null;

        renderAll();
        await commitState();
        showMessage('Movido.');
      }

      // desbloqueia no primeiro gesto do usu√°rio
      document.addEventListener('pointerdown', unlockAudio, { once: true, passive: true });
      document.addEventListener('keydown', unlockAudio, { once: true });

      function playCanastraSfx(kind) {
        if (!audioUnlocked) return;
        const a = CANASTRA_SFX[kind] || CANASTRA_SFX.suja;
        try {
          a.pause();
          a.currentTime = 0;
        } catch (e) {}
        a.play().catch(() => {});
      }

      function playTone(freq, t0, dur, vol = 0.12, type = 'sine') {
        if (!audioUnlocked || !audioCtx) return;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = type;
        o.frequency.setValueAtTime(freq, t0);

        // envelope curto (ataque/decay) pra n√£o estourar
        g.gain.setValueAtTime(0.0001, t0);
        g.gain.exponentialRampToValueAtTime(vol, t0 + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

        o.connect(g).connect(audioCtx.destination);
        o.start(t0);
        o.stop(t0 + dur + 0.02);
      }

      // function playCanastraSfx(kind) {
      //   // se o navegador ainda n√£o liberou √°udio, n√£o faz nada (evita erro)
      //   if (!audioUnlocked || !audioCtx) return;

      //   const t = audioCtx.currentTime + 0.01;

      //   // sons diferentes por tipo (simples e curto)
      //   if (kind === 'limpa') {
      //     playTone(660, t + 0.0, 0.1, 0.12, 'triangle');
      //     playTone(880, t + 0.11, 0.12, 0.13, 'triangle');
      //     return;
      //   }

      //   if (kind === 'suja') {
      //     playTone(330, t + 0.0, 0.12, 0.13, 'sawtooth');
      //     playTone(220, t + 0.13, 0.16, 0.11, 'sawtooth');
      //     return;
      //   }

      //   if (kind === 'real') {
      //     playTone(523.25, t + 0.0, 0.1, 0.11, 'sine'); // C
      //     playTone(659.25, t + 0.1, 0.1, 0.11, 'sine'); // E
      //     playTone(783.99, t + 0.2, 0.14, 0.13, 'sine'); // G
      //     return;
      //   }

      //   if (kind === 'asas') {
      //     playTone(740, t + 0.0, 0.08, 0.12, 'square');
      //     playTone(880, t + 0.08, 0.08, 0.12, 'square');
      //     playTone(1046.5, t + 0.16, 0.16, 0.14, 'square');
      //     return;
      //   }
      // }

      // mem√≥ria: "teamId:meldIdx" -> kind
      let canastraMemPrimed = false;
      const canastraKindMem = new Map();

      function resetCanastraSfxMemory() {
        canastraKindMem.clear();
        canastraMemPrimed = false;
      }

      function computeMeldKindMap() {
        const m = new Map();
        if (!state?.teams) return m;

        for (const t of state.teams) {
          (t.melds || []).forEach((meld, idx) => {
            m.set(`${t.id}:${idx}`, classifyMeldForUi(meld).kind);
          });
        }
        return m;
      }

      function syncCanastraSfxFromState() {
        if (!state?.teams) return;

        const curr = computeMeldKindMap();

        // primeira vez: s√≥ prime (N√ÉO toca)
        if (!canastraMemPrimed) {
          canastraKindMem.clear();
          for (const [k, v] of curr) canastraKindMem.set(k, v);
          canastraMemPrimed = true;
          return;
        }

        // toca quando:
        // 1) vira canastra (simple -> n√£o-simple)
        // 2) muda o tipo (suja <-> limpa <-> real <-> asas)
        for (const [k, kind] of curr) {
          const prev = canastraKindMem.get(k);

          const isCanastra = kind !== 'simple';
          const wasSimple = prev === 'simple';
          const wasMissing = prev == null;
          const changedKind = prev != null && prev !== kind;

          if ((wasSimple && isCanastra) || (wasMissing && isCanastra) || (changedKind && isCanastra)) {
            playCanastraSfx(kind);
          }

          canastraKindMem.set(k, kind);
        }

        // limpa melds que sumiram
        for (const key of Array.from(canastraKindMem.keys())) {
          if (!curr.has(key)) canastraKindMem.delete(key);
        }
      }

      // ==========================
      // Destaque tempor√°rio: carta comprada
      // ==========================
      let lastBoughtCardId = null;
      let lastBoughtTimer = null;

      function newActionId() {
        return `a_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`;
      }

      function packCard(c) {
        if (!c) return null;
        ensureCardId(c);
        return { id: c.id, rank: c.rank, suit: c.suit, joker: !!c.joker, back: c.back || 'red' };
      }

      function ensureCardId(card) {
        if (!card) return null;
        if (!card.id) card.id = `c_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`;
        return card.id;
      }

      function flashBoughtCard(card) {
        const id = ensureCardId(card);
        if (!id) return;

        lastBoughtCardId = id;

        if (lastBoughtTimer) clearTimeout(lastBoughtTimer);
        lastBoughtTimer = setTimeout(() => {
          lastBoughtCardId = null;
          renderHand();
        }, 1200);

        renderHand(); // renderiza j√° com o highlight
      }

      // ==========================
      // ANIMA√á√ÉO: carta voadora (A -> B)
      // ==========================
      const ANIM_MS = 900;
      const ANIM_EASE = 'cubic-bezier(0.2, 0.8, 0.2, 1)';

      function suitClass(card) {
        return card.joker ? 'joker-card' : card.suit === '‚ô•' || card.suit === '‚ô¶' ? 'hearts' : 'spades';
      }

      function cardFrontHTML(card) {
        return card.joker ? `<div class="carta-canto">JOKER</div><div class="carta-icone">‚òÖ</div>` : `<div class="carta-canto">${card.rank}<br>${card.suit}</div><div class="carta-icone">${card.suit}</div>`;
      }

      function getRect(el) {
        const r = el.getBoundingClientRect();
        return { left: r.left, top: r.top, width: r.width, height: r.height };
      }

      function makeFlyEl(card, face = 'front') {
        const el = document.createElement('div');
        el.className = `carta fly-card ${suitClass(card)}`;

        if (face === 'back') {
          el.classList.add('back');
          el.classList.add(card.back === 'blue' ? 'back-blue' : 'back-red');
        }

        el.innerHTML = cardFrontHTML(card); // n√£o importa, porque .back * fica hidden
        document.body.appendChild(el);
        return el;
      }

      function setBox(el, rect) {
        el.style.left = rect.left + 'px';
        el.style.top = rect.top + 'px';
        el.style.width = rect.width + 'px';
        el.style.height = rect.height + 'px';
      }

      async function flyRectToRect(card, fromRect, toRect, face = 'front') {
        const fly = makeFlyEl(card, face);
        setBox(fly, fromRect);

        const dx = toRect.left - fromRect.left;
        const dy = toRect.top - fromRect.top;
        const sx = toRect.width / fromRect.width;
        const sy = toRect.height / fromRect.height;

        const anim = fly.animate(
          [
            { transform: `translate(0px, 0px) scale(1, 1)`, opacity: 1 },
            { transform: `translate(${dx}px, ${dy}px) scale(${sx}, ${sy})`, opacity: 1 },
          ],
          { duration: ANIM_MS, easing: ANIM_EASE, fill: 'forwards' }
        );

        try {
          await anim.finished;
        } finally {
          fly.remove();
        }
      }

      function impactSparksAt(x, y, opts = {}) {
        const particles = opts.particles ?? 10;
        const dist = opts.dist ?? 32;
        const dur = opts.dur ?? 320;

        // anel (pancada)
        const ring = document.createElement('div');
        ring.className = 'impact-ring';
        ring.style.left = x + 'px';
        ring.style.top = y + 'px';
        document.body.appendChild(ring);

        ring
          .animate(
            [
              { transform: 'translate(-50%, -50%) scale(0.15)', opacity: 0.95 },
              { transform: 'translate(-50%, -50%) scale(1.25)', opacity: 0.0 },
            ],
            { duration: dur, easing: 'cubic-bezier(.2,.9,.2,1)', fill: 'forwards' }
          )
          .finished.finally(() => ring.remove());

        // fa√≠scas
        for (let i = 0; i < particles; i++) {
          const sp = document.createElement('div');
          sp.className = 'spark';
          sp.style.left = x + 'px';
          sp.style.top = y + 'px';
          document.body.appendChild(sp);

          const ang = Math.random() * Math.PI * 2;
          const d = dist * (0.55 + Math.random() * 0.75);
          const dx = Math.cos(ang) * d;
          const dy = Math.sin(ang) * d;
          const rot = Math.random() * 160 - 80;

          sp.animate(
            [
              { transform: `translate(-50%, -50%) rotate(${rot}deg) translate(0px,0px)`, opacity: 1 },
              { transform: `translate(-50%, -50%) rotate(${rot}deg) translate(${dx}px,${dy}px)`, opacity: 0 },
            ],
            { duration: dur, easing: 'cubic-bezier(.2,.9,.2,1)', fill: 'forwards' }
          ).finished.finally(() => sp.remove());
        }
      }

      function impactAtRect(toRect) {
        if (!toRect) return;
        const x = toRect.left + toRect.width / 2;
        const y = toRect.top + toRect.height / 2;
        impactSparksAt(x, y, { particles: 10, dist: 34, dur: 320 });
      }

      function cardElById(cardId) {
        return document.querySelector(`#handContainer .carta[data-card-id="${cardId}"]`);
      }

      function meldElByKey(key) {
        return document.querySelector(`.meld-line[data-meld-key="${key}"]`);
      }

      function meldDropRect(key, offset = 0) {
        const meldEl = meldElByKey(key);
        const row = meldEl ? meldEl.querySelector('.meld-line-cards') : null;
        const r = row ? row.getBoundingClientRect() : null;
        if (!r) return null;

        // ‚Äúfim do trilho‚Äù + offset pra m√∫ltiplas cartas n√£o ca√≠rem no mesmo pixel
        return { left: r.left + r.width - 28 - offset, top: r.top, width: 28, height: 40 };
      }

      function updateTimerLabel() {
        const el = document.getElementById('turnTimerLabel');
        if (!el) return;
        if (!state || state.finished || state.currentPlayer !== myPlayerIndex) {
          el.textContent = '';
          return;
        }
        el.textContent = `${turnTimerRemaining}s`;
      }

      function stopTurnTimer() {
        if (turnTimerId !== null) {
          clearInterval(turnTimerId);
          turnTimerId = null;
        }
      }

      let committing = false;
      let pendingCommit = false;

      async function commitState() {
        if (!state) return;

        pendingCommit = true;
        if (committing) return;

        committing = true;
        try {
          while (pendingCommit) {
            pendingCommit = false;
            await updateDoc(gameRef, {
              stateJson: JSON.stringify(state),
              updatedAt: Date.now(),
            });
          }
        } catch (err) {
          console.error('commitState failed:', err);
        } finally {
          committing = false;
        }
      }

      async function autoPlayTimeout() {
        if (!ensureMyTurn()) return;
        if (!state.hasDrawnThisTurn) {
          if (!state.stock.length) recycleDeadToStockIfPossible();
          if (state.stock.length) {
            const c = state.stock.pop();
            const me = currentPlayer();
            me.hand.push(c);
            sortHand(me.hand);
            state.hasDrawnThisTurn = true;
          } else if (state.discard.length && state.variant === 'aberto') {
            const c = state.discard.pop();
            const me = currentPlayer();
            me.hand.push(c);
            sortHand(me.hand);
            state.hasDrawnThisTurn = true;
          }
        }
        const me = currentPlayer();
        const hand = me.hand;
        if (!hand.length) {
          await commitState();
          return;
        }
        if (state.variant === 'fechado' && state.requiredDiscardCard) {
          showMessage('Tempo esgotado, obrigat√≥rio usar descarte (regra fechada).');
          return;
        }
        const idx = Math.floor(Math.random() * hand.length);
        const card = hand.splice(idx, 1)[0];
        state.discard.push(card);

        const teamId = me.teamId;
        const taken = state.deadChunksTaken?.[teamId] ?? 0;
        const max = state.deadChunksMax?.[teamId] ?? 1;

        // se ficou sem carta, tenta pegar morto automaticamente
        let tookDead = null;
        if (hand.length === 0) {
          tookDead = takeDeadIfAvailableForPlayer(me);
        }

        // se ainda t√° sem carta e n√£o pegou morto: fim do jogo
        if (hand.length === 0 && !tookDead && taken >= max) {
          await finishGame(teamId);
          return;
        }

        if (state.mode === '1x1_duploMorto') {
          if (state.currentPlayer === 1) {
            if (!state.j2ConsecutiveTurns || state.j2ConsecutiveTurns === 0) {
              state.j2ConsecutiveTurns = 1;
            } else {
              state.currentPlayer = 0;
              state.j2ConsecutiveTurns = 0;
            }
          } else {
            state.currentPlayer = 1;
            state.j2ConsecutiveTurns = 0;
          }
        } else {
          state.currentPlayer = (state.currentPlayer + 1) % state.players.length;
        }

        state.hasDrawnThisTurn = false;
        state.requiredDiscardCard = null;
        showMessage('Tempo esgotado: auto-play.');
        await commitState();
      }

      function classifyMeldForUi(meld) {
        if (!meld || meld.length < 7) return { kind: 'simple', base: 'Jogo', tag: null };

        const hasWild = meld.some((c) => c.joker || isWildcard(c, meld));

        // cartas "reais" pra analisar sequ√™ncia (ignora jokers e coringas)
        const realCards = meld.filter((c) => !c.joker && !isWildcard(c, meld));
        if (!realCards.length) return { kind: 'simple', base: 'Jogo', tag: null };

        const sameSuit = realCards.every((c) => c.suit === realCards[0].suit);

        const orderLow = {};
        RANKS_SEQ_LOW.forEach((r, i) => (orderLow[r] = i));
        const orderHigh = {};
        RANKS_SEQ.forEach((r, i) => (orderHigh[r] = i));

        const ranks = realCards.map((c) => c.rank);
        const aceCount = ranks.filter((r) => r === 'A').length;
        const hasKing = ranks.includes('K');

        function isContiguous(order) {
          const idxs = [...new Set(ranks.map((r) => order[r]).filter((v) => v != null))].sort((a, b) => a - b);
          if (idxs.length < 2) return true;
          for (let i = 1; i < idxs.length; i++) if (idxs[i] !== idxs[i - 1] + 1) return false;
          return true;
        }

        const contiguousLow = sameSuit && isContiguous(orderLow);
        const contiguousHigh = sameSuit && isContiguous(orderHigh);
        const isSeq = isValidSequenceMeld(meld);

        // Se tem coringa ‚Üí suja (prioridade)
        if (hasWild) return { kind: 'suja', base: 'Canastra', tag: { cls: 'suja', text: 'Suja' } };
        if (!isSeq) return { kind: 'simple', base: 'Jogo', tag: null };

        // √Ås-a-√Ås: A + (2..K) + A (sem coringa)
        const need = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const isAsAs = aceCount >= 2 && hasKing && need.every((r) => ranks.includes(r));

        if (isAsAs) return { kind: 'asas', base: 'C. √Ås-√Ås', tag: { cls: 'asas', text: '√Ås-√Ås' } };

        // Real: A..K (sem coringa)
        const needReal = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const isReal = !hasWild && sameSuit && needReal.every((r) => ranks.includes(r)) && realCards.length === 13;
        if (isReal) return { kind: 'real', base: 'C. Real', tag: { cls: 'real', text: 'Real' } };

        return { kind: 'limpa', base: 'Canastra', tag: { cls: 'limpa', text: 'Limpa' } };
      }

      function startTurnTimerIfNeeded() {
        stopTurnTimer();
        if (!state || state.finished || state.currentPlayer !== myPlayerIndex) {
          updateTimerLabel();
          return;
        }
        turnTimerRemaining = 60;
        updateTimerLabel();
        turnTimerId = setInterval(() => {
          turnTimerRemaining--;
          if (turnTimerRemaining <= 0) {
            stopTurnTimer();
            autoPlayTimeout().catch(console.error);
          } else {
            updateTimerLabel();
          }
        }, 1000);
      }

      function createDeck() {
        const deck = [];
        for (let d = 0; d < 2; d++) {
          const back = d === 0 ? 'red' : 'blue'; // ‚úÖ 50/50
          for (const s of SUITS) {
            for (const r of RANKS) deck.push({ rank: r, suit: s, joker: false, back });
          }
          deck.push({ rank: 'JOKER', suit: '‚òÖ', joker: true, back });
          deck.push({ rank: 'JOKER', suit: '‚òÖ', joker: true, back });
        }
        return deck;
      }

      function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }

      function recycleDeadToStockIfPossible() {
        if (!state || state.stock.length) return false;
        if (!state.deadPiles || !state.deadPiles.length) return false;

        // ‚úÖ pega APENAS 1 morto por vez
        const idx = state.deadPiles.findIndex((pile) => pile && pile.length);
        if (idx === -1) return false;

        const collected = state.deadPiles[idx];
        state.deadPiles[idx] = [];

        shuffle(collected);
        state.stock = collected;

        return true;
      }

      function cardLabel(card) {
        if (card.joker) return 'JOKER';
        return card.rank + card.suit;
      }

      function isWildcard(card, meld = null) {
        if (!card) return false;
        if (card.joker) return true;
        if (card.rank !== '2' && card.rank !== 2) return false;

        // ‚úÖ override manual/da engine (n√£o depende da posi√ß√£o)
        if (card.forceWild) return true;
        if (card.forceNatural) return false;

        // 2 s√≥ √© "natural" quando estiver imediatamente ANTES do 3 do mesmo naipe
        if (!meld || !Array.isArray(meld)) return true;

        const idx = meld.indexOf(card);
        const next = idx >= 0 ? meld[idx + 1] : null;

        if (next && !next.joker && next.rank === '3' && next.suit === card.suit) {
          return false; // 2 natural
        }

        return true; // 2 coringa
      }

      function cardBasePoints(card) {
        if (card.joker) return 20;
        if (card.rank === 'A' || card.rank === '2') return 15;
        if (['3', '4', '5', '6', '7'].includes(card.rank)) return 5;
        return 10;
      }

      function hasRealWild(meld) {
        return meld.some((c) => isWildcard(c, meld));
      }

      function sortHand(hand) {
        const rankOrder = {};
        RANKS_SEQ.forEach((r, idx) => (rankOrder[r] = idx));
        hand.sort((a, b) => {
          if (a.joker && !b.joker) return 1;
          if (!a.joker && b.joker) return -1;
          if (a.suit === b.suit) return rankOrder[a.rank] - rankOrder[b.rank];
          return SUITS.indexOf(a.suit) - SUITS.indexOf(b.suit);
        });
      }

      async function startGame(mode, names, variant) {
        if (myPlayerIndex !== 0) {
          showMessage('S√≥ Jogador 1 inicia.');
          return;
        }
        const players = [];
        const teams = [];
        let playerConfigs = [];
        if (mode === '1x1' || mode === '1x1_duploMorto') {
          playerConfigs = [
            { name: names[0] || 'J1', team: 0 },
            { name: names[1] || 'J2', team: 1 },
          ];
        } else if (mode === '2x2') {
          playerConfigs = [
            { name: names[0] || 'J1', team: 0 },
            { name: names[1] || 'J2', team: 1 },
            { name: names[2] || 'J3', team: 0 },
            { name: names[3] || 'J4', team: 1 },
          ];
        } else if (mode === '1x2') {
          playerConfigs = [
            { name: names[0] || 'Solo', team: 0 },
            { name: names[1] || 'D1', team: 1 },
            { name: names[2] || 'D2', team: 1 },
          ];
        }
        playerConfigs.forEach((cfg, idx) => {
          players.push({ id: idx, name: cfg.name, teamId: cfg.team, hand: [] });
        });
        for (let t = 0; t < 2; t++) {
          const playerIndexes = players.filter((p) => p.teamId === t).map((p) => p.id);
          teams.push({ id: t, name: t === 0 ? 'Time 1' : 'Time 2', playerIndexes, melds: [] });
        }
        let stock = shuffle(createDeck());
        const discard = [];
        const deadPiles = [[], []];
        const HAND_SIZE = 11;
        for (let i = 0; i < HAND_SIZE; i++) for (let pIdx = 0; pIdx < players.length; pIdx++) players[pIdx].hand.push(stock.pop());
        for (let i = 0; i < DEAD_CHUNK_SIZE; i++) {
          deadPiles[0].push(stock.pop());
          deadPiles[1].push(stock.pop());
        }
        players.forEach((p) => sortHand(p.hand));
        discard.push(stock.pop());
        let deadChunksMax = [1, 1];
        if (mode === '1x1_duploMorto') deadChunksMax = [1, 2];
        const newState = {
          mode,
          variant,
          players,
          teams,
          currentPlayer: 0,
          stock,
          discard,
          deadPiles,
          deadChunksTaken: [0, 0],
          deadChunksMax,
          hasDrawnThisTurn: false,
          finished: false,
          winnerTeamId: null,
          j2ConsecutiveTurns: 0,
          requiredDiscardCard: null,
        };
        await setDoc(gameRef, { stateJson: JSON.stringify(newState), createdAt: Date.now() });
        showMessage('Partida iniciada!');
      }

      function currentPlayer() {
        return state.players[state.currentPlayer];
      }
      function currentTeam() {
        return state.teams[currentPlayer().teamId];
      }
      function ensureMyTurn() {
        if (!state || state.finished) {
          showMessage('Fim de jogo.');
          return false;
        }
        if (state.currentPlayer !== myPlayerIndex) {
          showMessage('Aguarde sua vez.');
          return false;
        }
        return true;
      }

      function hasAnyDeadToRecycle() {
        return !!state?.deadPiles?.some((p) => p && p.length);
      }

      // ‚úÖ morto ‚Äúdispon√≠vel‚Äù para esta equipe pegar agora (considera humilha√ß√£o: J2 pode pegar 2)
      function canTeamTakeDead(teamId) {
        const taken = state.deadChunksTaken?.[teamId] ?? 0;
        const max = state.deadChunksMax?.[teamId] ?? 1;
        if (taken >= max) return false;

        let deadIndex = teamId;

        // 1x1 humilha√ß√£o: teamId 1 (Jogador 2) pode pegar o 2¬∫ morto se ele existir
        if (state.mode === '1x1_duploMorto' && teamId === 1 && taken >= 1) {
          if (!state.deadPiles?.[deadIndex]?.length) deadIndex = 0;
        }

        return !!state.deadPiles?.[deadIndex]?.length;
      }

      // ‚úÖ para bater: precisa ter pelo menos 1 canastra limpa/real/√°s-√°s na equipe
      function teamHasGoodCanastra(teamId) {
        const team = state.teams[teamId];
        if (!team?.melds?.length) return false;

        return team.melds.some((m) => {
          if (!m || m.length < 7) return false;
          const kind = classifyMeldForUi(m).kind;
          return kind === 'limpa' || kind === 'real' || kind === 'asas';
        });
      }

      async function drawFromStock() {
        if (!ensureMyTurn()) return;
        if (state.hasDrawnThisTurn) {
          showMessage('J√° comprou.');
          return;
        }

        const fromEl = document.querySelector('#drawStockBtn .pile-card');
        const fromRect = fromEl ? getRect(fromEl) : null;

        if (!state.stock.length) {
          if (!recycleDeadToStockIfPossible() || !state.stock.length) {
            showMessage('Monte acabou e n√£o h√° morto para recolocar. Fim de jogo.');
            await finishGame(null);
            return;
          } else showMessage('Morto virou monte.');
        }

        const c = state.stock.pop();
        ensureCardId(c);

        currentPlayer().hand.push(c);
        sortHand(currentPlayer().hand);
        state.hasDrawnThisTurn = true;

        // render pra achar o destino no DOM
        lastBoughtCardId = null;
        renderHand();

        const toEl = cardElById(c.id);
        if (fromRect && toEl) {
          const toRect = getRect(toEl);
          toEl.style.visibility = 'hidden';
          await flyRectToRect(c, fromRect, toRect, 'back'); // do monte: eu animaria ‚Äúverso‚Äù
          toEl.style.visibility = '';
        }

        flashBoughtCard(c);

        state.lastAction = { id: newActionId(), type: 'drawStock', playerId: state.currentPlayer, card: packCard(c), ts: Date.now() };
        ignoreOwnActionId = state.lastAction.id;

        // BUG REAL: antes voc√™ n√£o commitava compra do monte (outros players n√£o veem)
        await commitState();
      }

      function canUseDiscardInClosed(discardTop, hand, team) {
        if (!discardTop) return false;
        const n = hand.length;
        const pool = hand.concat([discardTop]);
        const idxTopo = pool.length - 1;
        const totalMasks = 1 << pool.length;
        for (let mask = 0; mask < totalMasks; mask++) {
          if (!(mask & (1 << idxTopo))) continue;
          const subset = [];
          for (let i = 0; i < pool.length; i++) if (mask & (1 << i)) subset.push(pool[i]);
          if (subset.length >= 3 && isValidSequenceMeld(subset)) return true;
        }
        if (team && team.melds && team.melds.length) {
          for (const meld of team.melds) {
            const base = meld;
            const maxMask2 = 1 << n;
            for (let mask = 0; mask < maxMask2; mask++) {
              const subset = base.slice();
              subset.push(discardTop);
              for (let i = 0; i < n; i++) if (mask & (1 << i)) subset.push(hand[i]);
              if (isValidSequenceMeld(subset)) return true;
            }
          }
        }
        return false;
      }

      async function drawFromDiscard() {
        if (!ensureMyTurn()) return;
        if (state.hasDrawnThisTurn) {
          showMessage('J√° comprou.');
          return;
        }
        // ‚úÖ regra da casa: se monte acabou e n√£o existe morto -> fim imediato (mesmo com lixo)
        if (!state.stock.length && !hasAnyDeadToRecycle()) {
          showMessage('Monte acabou e n√£o h√° morto para recolocar. Fim de jogo.');
          await finishGame(null);
          return;
        }

        if (!state.discard.length) {
          showMessage('Lixo vazio.');
          return;
        }

        const fromEl = document.getElementById('discardFace');
        const fromRect = fromEl ? getRect(fromEl) : null;

        const top = state.discard[state.discard.length - 1];
        ensureCardId(top);
        const me = currentPlayer();

        if (state.variant === 'fechado') {
          const canUse = canUseDiscardInClosed(top, me.hand, currentTeam());
          if (!canUse) {
            showMessage('Fechado: a carta deve servir p/ jogo.');
            return;
          }
        }

        const pile = state.discard.splice(0, state.discard.length);
        pile.forEach(ensureCardId);

        me.hand.push(...pile);
        sortHand(me.hand);

        state.hasDrawnThisTurn = true;
        if (state.variant === 'fechado') state.requiredDiscardCard = { rank: top.rank, suit: top.suit, joker: !!top.joker };
        else state.requiredDiscardCard = null;

        // render pra achar destino do "top" no DOM
        lastBoughtCardId = null;
        renderHand();

        const toEl = cardElById(top.id);
        if (fromRect && toEl) {
          const toRect = getRect(toEl);
          toEl.style.visibility = 'hidden';
          await flyRectToRect(top, fromRect, toRect, 'front'); // do lixo: faz sentido mostrar a face
          toEl.style.visibility = '';
        }

        flashBoughtCard(top);

        state.lastAction = { id: newActionId(), type: 'drawDiscard', playerId: state.currentPlayer, card: packCard(top), ts: Date.now() };
        ignoreOwnActionId = state.lastAction.id;

        await commitState();
      }

      function isValidSequenceMeld(cards) {
        if (!cards || cards.length < 3) return false;
        const wildCards = cards.filter((c) => isWildcard(c, cards));
        if (wildCards.length > 1) return false;
        const nonWild = cards.filter((c) => !isWildcard(c, cards));
        if (!nonWild.length) return false;
        const suit = nonWild[0].suit;
        if (!nonWild.every((c) => c.suit === suit)) return false;
        const availableWilds = cards.length - nonWild.length;

        function neededWildsForOrder(order, aceMode) {
          const seqOrder = {};
          order.forEach((r, i) => (seqOrder[r] = i));
          const sorted = nonWild.slice().sort((a, b) => seqOrder[a.rank] - seqOrder[b.rank]);
          const acePosInOrder = seqOrder['A'];
          const aceIndex = sorted.findIndex((c) => c.rank === 'A');
          if (aceIndex !== -1) {
            if (aceMode === 'high' && aceIndex !== sorted.length - 1) return null;
            if (aceMode === 'low' && aceIndex !== 0) return null;
            if (aceMode === 'none') return null;
          }
          let needed = 0;
          for (let i = 1; i < sorted.length; i++) {
            const prev = seqOrder[sorted[i - 1].rank];
            const curr = seqOrder[sorted[i].rank];
            if (prev == null || curr == null) return null;
            const diff = curr - prev;
            if (diff <= 0) return null;
            if (diff > 1) needed += diff - 1;
          }
          return needed;
        }
        const needHigh = neededWildsForOrder(RANKS_SEQ, 'high');
        const needLow = neededWildsForOrder(RANKS_SEQ_LOW, 'low');

        const baseOk = (needHigh !== null && needHigh <= availableWilds) || (needLow !== null && needLow <= availableWilds);
        if (baseOk) return true;

        // ‚úÖ SPECIAL: "√Ås a √Ås" (A-2-3-...-K-A)
        const aceCount = nonWild.filter((c) => c.rank === 'A').length;
        const hasKing = nonWild.some((c) => c.rank === 'K');
        if (aceCount >= 2 && hasKing) {
          // remove 1 √Ås (o de fechamento) e testa como sequ√™ncia "low" normal
          const idxAceToRemove = nonWild.findIndex((c, i) => c.rank === 'A' && i !== nonWild.findIndex((x) => x.rank === 'A'));
          if (idxAceToRemove !== -1) {
            const test = nonWild.slice();
            test.splice(idxAceToRemove, 1);

            const seqOrder = {};
            RANKS_SEQ_LOW.forEach((r, i) => (seqOrder[r] = i));
            const sorted = test.slice().sort((a, b) => seqOrder[a.rank] - seqOrder[b.rank]);
            const aceIdx = sorted.findIndex((c) => c.rank === 'A');
            if (aceIdx === 0) {
              let needed = 0;
              let ok = true;
              for (let i = 1; i < sorted.length; i++) {
                const prev = seqOrder[sorted[i - 1].rank];
                const curr = seqOrder[sorted[i].rank];
                if (prev == null || curr == null) {
                  ok = false;
                  break;
                }
                const diff = curr - prev;
                if (diff <= 0) {
                  ok = false;
                  break;
                }
                if (diff > 1) needed += diff - 1;
              }
              if (ok && needed <= availableWilds) return true;
            }
          }
        }

        return false;
      }

      async function attemptExtendExistingMeld(cards, indexes) {
        const team = currentTeam();
        if (!team.melds || !team.melds.length) return false;
        const hand = currentPlayer().hand;
        let forcedIndex = null;
        if (selectedMeldTarget) {
          const [teamIdStr, meldIdxStr] = selectedMeldTarget.split(':');
          if (parseInt(teamIdStr) === team.id && team.melds[parseInt(meldIdxStr)]) forcedIndex = parseInt(meldIdxStr);
        }
        if (forcedIndex !== null) {
          const targetMeld = team.melds[forcedIndex];
          const combined = targetMeld.concat(cards);
          if (!isValidSequenceMeld(combined)) {
            showMessage('N√£o encaixa.');
            return false;
          }

          const key = team.id + ':' + forcedIndex;
          const baseDrop = meldDropRect(key, 0);
          if (baseDrop) {
            const anims = cards.map((c, i) => {
              const from = cardElById(c.id);
              if (!from) return Promise.resolve();
              const fromRect = getRect(from);
              from.style.visibility = 'hidden';
              const toRect = { ...baseDrop, left: baseDrop.left - i * 10, top: baseDrop.top + i * 2 };
              return flyRectToRect(c, fromRect, toRect, 'front').then(() => impactAtRect(toRect));
            });
            await Promise.all(anims);
          }

          for (const idx of indexes) {
            targetMeld.push(hand[idx]);
            hand.splice(idx, 1);
          }
          normalizeMeldOrder(targetMeld); // mant√©m tua ordena√ß√£o padr√£o
          autoSwapWildWhenFillingGap(targetMeld); // ‚úÖ libera o 2 quando a carta ‚Äúreal‚Äù entrou
          normalizeMeldOrder(targetMeld); // reordena de novo depois do swap (agora com forceWild)

          sortHand(hand);
          selectedHandIndexes.clear();
          selectedMeldTarget = null;

          // üî• avisa os outros o que aconteceu
          state.lastAction = {
            id: newActionId(),
            type: 'meldExtend',
            playerId: myPlayerIndex, // ou state.currentPlayer (os 2 batem na tua vez)
            teamId: team.id,
            meldIndex: forcedIndex,
            cards: cards.map(packCard),
            ts: Date.now(),
          };
          ignoreOwnActionId = state.lastAction.id;

          await commitState();
          showMessage('Cartas adicionadas!');
          return true;
        }
        const candidateMeldIndexes = [];
        team.melds.forEach((meld, idx) => {
          if (isValidSequenceMeld(meld.concat(cards))) candidateMeldIndexes.push(idx);
        });
        if (!candidateMeldIndexes.length) return false;
        if (candidateMeldIndexes.length > 1) {
          showMessage('Encaixa em v√°rios. Selecione o jogo.');
          return false;
        }
        const teamMeld = team.melds[candidateMeldIndexes[0]];
        const key = team.id + ':' + candidateMeldIndexes[0];

        for (const idx of indexes) {
          teamMeld.push(hand[idx]);
          hand.splice(idx, 1);
        }
        normalizeMeldOrder(teamMeld);
        sortHand(hand);
        selectedHandIndexes.clear();
        selectedMeldTarget = null;

        // üî• avisa os outros o que aconteceu
        state.lastAction = {
          id: newActionId(),
          type: 'meldExtend',
          playerId: myPlayerIndex,
          teamId: team.id,
          meldIndex: candidateMeldIndexes[0],
          cards: cards.map(packCard),
          ts: Date.now(),
        };
        ignoreOwnActionId = state.lastAction.id;

        await commitState();
        return true;
      }

      async function makeMeldFromSelection() {
        if (!ensureMyTurn()) return;
        if (!state.hasDrawnThisTurn) {
          showMessage('Compre primeiro.');
          return;
        }

        const hand = currentPlayer().hand;
        const indexes = Array.from(selectedHandIndexes).sort((a, b) => b - a);

        if (!indexes.length) {
          showMessage('Selecione cartas.');
          return;
        }

        const cards = indexes.map((i) => hand[i]);

        const extended = await attemptExtendExistingMeld(cards, indexes);
        if (extended) return;

        if (indexes.length < 3) {
          showMessage('Novo jogo: m√≠n 3 cartas.');
          return;
        }

        if (!isValidSequenceMeld(cards)) {
          showMessage('Sequ√™ncia inv√°lida.');
          return;
        }

        // ===== 5.4B: ANIMA√á√ÉO (m√£o -> √°rea de jogos do time) =====
        cards.forEach(ensureCardId);

        const teamId = currentTeam().id;
        const targetContainer = document.getElementById(teamId === 0 ? 'meldsP1' : 'meldsP2');

        if (targetContainer) {
          const tr = targetContainer.getBoundingClientRect();
          const dropBase = { left: tr.left + tr.width - 30, top: tr.top + 10, width: 22, height: 30 };

          const anims = cards.map((c, i) => {
            const from = cardElById(c.id);
            if (!from) return Promise.resolve();

            const fromRect = getRect(from);
            from.style.visibility = 'hidden';

            const toRect = { ...dropBase, left: dropBase.left - i * 10, top: dropBase.top + i * 2 };
            return flyRectToRect(c, fromRect, toRect, 'front').then(() => impactAtRect(toRect));
          });

          await Promise.all(anims);
        }
        // ===== fim anima√ß√£o =====

        const meld = [];
        for (const idx of indexes) {
          meld.unshift(hand[idx]);
          hand.splice(idx, 1);
        }

        normalizeMeldOrder(meld);

        // adiciona o jogo no state
        const teamId2 = currentTeam().id;
        currentTeam().melds.push(meld);

        // calcula a key do meld rec√©m criado (importante pro meldDropRect funcionar)
        const meldIdx = currentTeam().melds.length - 1;
        const meldKey = teamId2 + ':' + meldIdx;

        // üî• PUBLICA A A√á√ÉO PROS OUTROS ANIMAREM
        state.lastAction = {
          id: newActionId(),
          type: 'meldNew',
          playerId: myPlayerIndex,
          teamId: currentTeam().id,
          meldIndex: meldIdx, // ‚úÖ ADICIONA ISSO
          cards: cards.map(packCard),
          ts: Date.now(),
        };

        ignoreOwnActionId = state.lastAction.id;

        selectedHandIndexes.clear();
        await commitState();
      }

      function takeDeadIfAvailableForPlayer(p) {
        if (!state || !p) return null;

        const teamId = p.teamId;
        const taken = state.deadChunksTaken?.[teamId] ?? 0;
        const max = state.deadChunksMax?.[teamId] ?? 1;
        if (taken >= max) return null;

        // regra: s√≥ pega morto com a m√£o vazia
        if (p.hand.length !== 0) return null;

        let deadIndex = teamId;

        // 1x1 humilha√ß√£o: team 1 pode pegar o 2¬∫ morto (fallback pro 0)
        if (state.mode === '1x1_duploMorto' && teamId === 1 && taken >= 1) {
          if (!state.deadPiles?.[deadIndex]?.length) deadIndex = 0;
        }

        const dead = state.deadPiles?.[deadIndex];
        if (!dead || !dead.length) return null;

        const chunkSize = Math.min(DEAD_CHUNK_SIZE, dead.length);
        p.hand.push(...dead.splice(0, chunkSize));
        sortHand(p.hand);
        state.deadChunksTaken[teamId] = taken + 1;

        return { deadIndex, count: chunkSize };
      }

      async function takeDead() {
        if (!ensureMyTurn()) return;
        const p = currentPlayer();
        const teamId = p.teamId;
        const taken = state.deadChunksTaken?.[teamId] ?? 0;
        const max = state.deadChunksMax?.[teamId] ?? 1;
        if (taken >= max) {
          showMessage('Sem mortos p/ sua equipe.');
          return;
        }
        if (p.hand.length > 0) {
          showMessage('M√£o deve estar vazia.');
          return;
        }
        let deadIndex = teamId;
        if (state.mode === '1x1_duploMorto' && teamId === 1 && taken >= 1) {
          if (!state.deadPiles[deadIndex].length) deadIndex = 0;
        }
        const dead = state.deadPiles[deadIndex];
        if (!dead || !dead.length) {
          showMessage('Morto vazio.');
          return;
        }
        const chunkSize = Math.min(DEAD_CHUNK_SIZE, dead.length);
        const fromSlot = document.getElementById(deadIndex === 0 ? 'mortoSlot0' : 'mortoSlot1');
        const handArea = document.getElementById('handContainer');

        if (fromSlot && handArea) {
          const fr = fromSlot.getBoundingClientRect();
          const hr = handArea.getBoundingClientRect();

          // anima s√≥ ‚Äúuma carta‚Äù do morto (stack fake)
          const fakeCard = { rank: '‚òÖ', suit: '‚òÖ', joker: true, id: `dead_${Date.now()}` };
          const fromRect = { left: fr.left, top: fr.top, width: fr.width, height: fr.height };
          const toRect = { left: hr.left + hr.width * 0.5, top: hr.top + 10, width: 60, height: 90 };

          await flyRectToRect(fakeCard, fromRect, toRect, 'back');
        }

        p.hand.push(...dead.splice(0, chunkSize));
        sortHand(p.hand);
        state.deadChunksTaken[teamId] = taken + 1;

        state.lastAction = {
          id: newActionId(),
          type: 'takeDead',
          playerId: state.currentPlayer,
          deadIndex,
          count: chunkSize,
          ts: Date.now(),
        };
        ignoreOwnActionId = state.lastAction.id;

        await commitState();
      }

      function canTeamTakeDeadNow(teamId) {
        const taken = state.deadChunksTaken?.[teamId] ?? 0;
        const max = state.deadChunksMax?.[teamId] ?? 1;
        if (taken >= max) return false;

        let deadIndex = teamId;

        // 1x1 humilha√ß√£o: jogador 2 (team 1) pode pegar o 2¬∫ morto
        if (state.mode === '1x1_duploMorto' && teamId === 1 && taken >= 1) {
          deadIndex = 0;
        }

        return !!state.deadPiles?.[deadIndex]?.length;
      }

      async function discardSelectedCard() {
        if (!ensureMyTurn()) return;
        if (!state.hasDrawnThisTurn) {
          showMessage('Compre primeiro.');
          return;
        }

        if (state.variant === 'fechado' && state.requiredDiscardCard) {
          const must = state.requiredDiscardCard;
          const stillInHand = currentPlayer().hand.some((c) => c.rank === must.rank && c.suit === must.suit && !!c.joker === !!must.joker);
          if (stillInHand) {
            showMessage('Use a carta do lixo antes.');
            return;
          }
        }

        const p = currentPlayer();
        const hand = p.hand;

        const indexes = Array.from(selectedHandIndexes);
        if (indexes.length !== 1) {
          showMessage('Selecione 1 carta.');
          return;
        }

        const index = indexes[0];
        const card = hand[index];
        ensureCardId(card);

        const fromEl = cardElById(card.id);
        const toEl = document.getElementById('discardFace');

        if (fromEl && toEl) {
          const fromRect = getRect(fromEl);
          const toRect = getRect(toEl);
          fromEl.style.visibility = 'hidden';
          await flyRectToRect(card, fromRect, toRect, 'front');
          fromEl.style.visibility = '';
        }

        // 1) mexe no state
        hand.splice(index, 1);
        state.discard.push(card);
        selectedHandIndexes.clear();

        // 2) se ficou sem carta, tenta pegar morto automaticamente
        let tookDead = null;
        if (hand.length === 0) {
          tookDead = takeDeadIfAvailableForPlayer(p); // retorna {deadIndex,count} ou null
        }

        // 3) se ainda t√° sem carta e n√£o tem morto: fim do jogo
        const teamId = p.teamId;
        if (hand.length === 0 && !canTeamTakeDeadNow(teamId)) {
          await finishGame(teamId);
          return;
        }

        // 4) passa turno
        if (state.mode === '1x1_duploMorto') {
          if (state.currentPlayer === 1) {
            state.j2ConsecutiveTurns = !state.j2ConsecutiveTurns ? 1 : 0;
            if (state.j2ConsecutiveTurns === 0) state.currentPlayer = 0;
          } else {
            state.currentPlayer = 1;
            state.j2ConsecutiveTurns = 0;
          }
        } else {
          state.currentPlayer = (state.currentPlayer + 1) % state.players.length;
        }

        state.requiredDiscardCard = null;
        state.hasDrawnThisTurn = false;

        // 5) publica a√ß√£o pros outros animarem
        state.lastAction = {
          id: newActionId(),
          type: 'discard',
          playerId: myPlayerIndex,
          card: packCard(card),
          tookDead, // {deadIndex,count} ou null
          ts: Date.now(),
        };
        ignoreOwnActionId = state.lastAction.id;

        await commitState();
      }

      function computeTeamMeldScore(team) {
        let meldPoints = 0,
          sujaBonus = 0,
          limpaBonus = 0,
          realBonus = 0,
          asasBonus = 0;
        if (!team || !team.melds) return { total: 0 };
        team.melds.forEach((meld) => {
          meld.forEach((c) => (meldPoints += cardBasePoints(c)));
          if (meld.length >= 7) {
            const info = classifyMeldForUi(meld);
            if (info.kind === 'suja') sujaBonus += 100;
            if (info.kind === 'limpa') limpaBonus += 200;
            if (info.kind === 'real') realBonus += 500;
            if (info.kind === 'asas') asasBonus += 1000;
          }
        });
        return { meldPoints, sujaBonus, limpaBonus, realBonus, asasBonus, total: meldPoints + sujaBonus + limpaBonus + realBonus + asasBonus };
      }

      function normalizeMeldOrder(meld) {
        // (L√≥gica complexa de ordena√ß√£o mantida intacta)
        if (!meld || !meld.length) return;
        const nonWild = meld.filter((c) => !isWildcard(c, meld));
        const wild = meld.filter((c) => isWildcard(c, meld));
        if (!nonWild.length) {
          meld.splice(0, meld.length, ...wild);
          return;
        }

        // ‚úÖ SPECIAL: ordena√ß√£o de "√Ås a √Ås" (A-2-3-...-K-A)
        // Mant√©m o √Ås final como a "carta fechada" no fim do jogo.
        const aces = nonWild.filter((c) => c.rank === 'A');
        const hasKing = nonWild.some((c) => c.rank === 'K');
        if (aces.length >= 2 && hasKing) {
          const closingAce = aces[1];
          const baseNonWild = nonWild.filter((c) => c !== closingAce);
          const seqOrderLow = {};
          RANKS_SEQ_LOW.forEach((r, i) => (seqOrderLow[r] = i));

          const sortedNonWild = baseNonWild.slice().sort((a, b) => seqOrderLow[a.rank] - seqOrderLow[b.rank]);
          const middle = [];
          const wildQueue = [...wild];

          for (let i = 0; i < sortedNonWild.length; i++) {
            middle.push(sortedNonWild[i]);
            if (i < sortedNonWild.length - 1) {
              let gap = seqOrderLow[sortedNonWild[i + 1].rank] - seqOrderLow[sortedNonWild[i].rank] - 1;
              while (gap > 0 && wildQueue.length) {
                middle.push(wildQueue.shift());
                gap--;
              }
            }
          }

          const suffix = [];
          while (wildQueue.length) suffix.push(wildQueue.shift());

          meld.splice(0, meld.length, ...middle, ...suffix, closingAce);
          return;
        }

        const availableWilds = wild.length;
        function neededWildsForOrder(order, aceMode) {
          const seqOrder = {};
          order.forEach((r, i) => (seqOrder[r] = i));
          const sorted = nonWild.slice().sort((a, b) => seqOrder[a.rank] - seqOrder[b.rank]);
          const aceIndex = sorted.findIndex((c) => c.rank === 'A');
          if (aceIndex !== -1) {
            if (aceMode === 'high' && aceIndex !== sorted.length - 1) return null;
            if (aceMode === 'low' && aceIndex !== 0) return null;
            if (aceMode === 'none') return null;
          }
          let needed = 0;
          for (let i = 1; i < sorted.length; i++) {
            const diff = seqOrder[sorted[i].rank] - seqOrder[sorted[i - 1].rank];
            if (diff <= 0) return null;
            if (diff > 1) needed += diff - 1;
          }
          return needed;
        }
        const needHigh = neededWildsForOrder(RANKS_SEQ, 'high');
        const needLow = neededWildsForOrder(RANKS_SEQ_LOW, 'low');
        const okHigh = needHigh !== null && needHigh <= availableWilds;
        const okLow = needLow !== null && needLow <= availableWilds;

        let order, aceMode;
        if (okHigh && okLow) {
          if (needHigh <= needLow) {
            order = RANKS_SEQ;
            aceMode = 'high';
          } else {
            order = RANKS_SEQ_LOW;
            aceMode = 'low';
          }
        } else if (okHigh) {
          order = RANKS_SEQ;
          aceMode = 'high';
        } else if (okLow) {
          order = RANKS_SEQ_LOW;
          aceMode = 'low';
        } else return;

        const seqOrder = {};
        order.forEach((r, i) => (seqOrder[r] = i));
        const sortedNonWild = nonWild.slice().sort((a, b) => seqOrder[a.rank] - seqOrder[b.rank]);
        const middle = [];
        const wildQueue = [...wild];
        for (let i = 0; i < sortedNonWild.length; i++) {
          middle.push(sortedNonWild[i]);
          if (i < sortedNonWild.length - 1) {
            let gap = seqOrder[sortedNonWild[i + 1].rank] - seqOrder[sortedNonWild[i].rank] - 1;
            while (gap > 0 && wildQueue.length) {
              middle.push(wildQueue.shift());
              gap--;
            }
          }
        }
        const prefix = [];
        const suffix = [];
        if (aceMode === 'high') {
          while (wildQueue.length) prefix.push(wildQueue.shift());
        } else {
          while (wildQueue.length) suffix.push(wildQueue.shift());
        }
        meld.splice(0, meld.length, ...prefix, ...middle, ...suffix);
      }

      function computeScores() {
        const results = [];
        state.teams.forEach((team) => {
          const players = state.players.filter((p) => p.teamId === team.id);
          let handPenalty = 0;
          players.forEach((p) => p.hand.forEach((c) => (handPenalty += cardBasePoints(c))));
          const meldInfo = computeTeamMeldScore(team);
          const deadTaken = state.deadChunksTaken?.[team.id] ?? 0;
          const mortoBonus = deadTaken > 0 ? 100 : 0;
          const mortoPenalty = deadTaken === 0 ? 100 : 0;
          const batidaBonus = state.finished && state.winnerTeamId === team.id ? 100 : 0;
          results.push({ team, players, score: meldInfo.total + batidaBonus + mortoBonus - mortoPenalty - handPenalty, handPenalty, batidaBonus, mortoBonus, mortoPenalty, ...meldInfo });
        });
        return results;
      }

      async function finishGame(winnerTeamId) {
        if (!state) return;
        state.finished = true;
        state.winnerTeamId = winnerTeamId ?? null;
        await commitState();
      }

      // RENDER
      function renderAll() {
        if (!state) return;

        // ‚úÖ orienta√ß√£o fixa por cliente (n√£o muda a cada turno)
        applyViewTeamClass();
        document.getElementById('currentPlayerLabel').textContent = currentPlayer().name;
        document.getElementById('stockCount').textContent = state.stock.length;

        // Descarte
        const discardTop = state.discard[state.discard.length - 1];
        document.getElementById('discardCount').textContent = state.discard.length;
        const discardFace = document.getElementById('discardFace');
        const fTop = document.getElementById('discardFaceTop');
        const fBot = document.getElementById('discardFaceBottom');
        if (!discardTop) discardFace.style.display = 'none';
        else {
          discardFace.style.display = 'flex';
          if (discardTop.joker) {
            fTop.textContent = '‚òÖ';
            fBot.textContent = '‚òÖ';
            discardFace.style.color = '#b45309';
          } else {
            fTop.innerHTML = discardTop.rank + '<br>' + discardTop.suit;
            fBot.textContent = discardTop.suit;
            discardFace.style.color = discardTop.suit === '‚ô•' || discardTop.suit === '‚ô¶' ? '#b91c1c' : '#000';
          }
        }

        // Mortos
        const s0 = document.getElementById('mortoSlot0');
        const s1 = document.getElementById('mortoSlot1');
        if (state.deadPiles.length >= 2) {
          s0.classList.toggle('used', state.deadPiles[0].length === 0);
          s1.classList.toggle('used', state.deadPiles[1].length === 0);
        }

        // M√£os Oponentes
        renderOpponentHands();

        // Minha M√£o
        renderHand();

        // Jogos
        renderMelds();

        // Bot√µes
        const myTurn = !state.finished && state.currentPlayer === myPlayerIndex;

        // bot√£o mover 2/Joker (habilita s√≥ quando faz sentido)
        const moveBtn = document.getElementById('moveWildBtn');
        if (moveBtn) {
          const me = state.players[myPlayerIndex];
          const myTeamId = me?.teamId;

          const dest = parseMeldKey(selectedMeldTarget) || (movingWild ? { teamId: movingWild.fromTeamId, meldIdx: movingWild.fromMeldIndex } : null);

          const can = myTurn && state.hasDrawnThisTurn && !!movingWild && dest && dest.teamId === myTeamId;

          moveBtn.disabled = !can;
        }

        // üîî Vibra quando passa a ser a minha vez
        if (myTurn && !lastMyTurn && navigator.vibrate) {
          navigator.vibrate([150, 80, 150]); // vibra, pausa, vibra
        }
        lastMyTurn = myTurn;

        document.getElementById('drawStockBtn').style.pointerEvents = myTurn && !state.hasDrawnThisTurn ? 'auto' : 'none';

        document.getElementById('drawStockBtn').style.opacity = myTurn && !state.hasDrawnThisTurn ? '1' : '0.5';

        document.getElementById('drawDiscardBtn').style.pointerEvents = myTurn && !state.hasDrawnThisTurn && state.discard.length ? 'auto' : 'none';
        document.getElementById('drawDiscardBtn').style.opacity = myTurn && !state.hasDrawnThisTurn && state.discard.length ? '1' : '0.5';

        // document.getElementById('meldBtn').disagbled = !myTurn || !state.hasDrawnThisTurn;
        document.getElementById('meldBtn').disabled = !myTurn || !state.hasDrawnThisTurn;

        document.getElementById('discardBtn').disabled = !myTurn || !state.hasDrawnThisTurn;

        const me = state.players[myPlayerIndex];
        const myTeamId = me.teamId;

        const taken = state.deadChunksTaken?.[myTeamId] ?? 0;
        const max = state.deadChunksMax?.[myTeamId] ?? 1;

        // opcional mas certo: s√≥ habilita morto se eu estiver com a m√£o vazia
        const canTakeDeadBtn = myTurn && me.hand.length === 0 && canTeamTakeDeadNow(myTeamId);

        document.getElementById('takeDeadBtn').disabled = !canTakeDeadBtn;

        document.getElementById('endGameBtn').disabled = false;

        if (state.finished) renderScores(computeScores(), state.winnerTeamId);
      }

      function renderHand() {
        const container = document.querySelector('#handContainer .cards-row');
        container.innerHTML = '';
        const me = state.players[myPlayerIndex];
        document.getElementById('handCountLabel').textContent = me.hand.length;
        me.hand.forEach((card, idx) => {
          ensureCardId(card);
          const div = document.createElement('div');
          div.dataset.cardId = card.id;
          div.className = 'carta ' + (card.joker ? 'joker-card' : card.suit === '‚ô•' || card.suit === '‚ô¶' ? 'hearts' : 'spades');
          if (card.id === lastBoughtCardId) {
            div.classList.add('just-bought');
            requestAnimationFrame(() => {
              div.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
            });
          }

          div.innerHTML = card.joker ? `<div class="carta-canto">JOKER</div><div class="carta-icone">‚òÖ</div>` : `<div class="carta-canto">${card.rank}<br>${card.suit}</div><div class="carta-icone">${card.suit}</div>`;
          if (selectedHandIndexes.has(idx)) div.classList.add('selected');
          div.onclick = () => {
            if (state.currentPlayer !== myPlayerIndex) return;
            if (selectedHandIndexes.has(idx)) selectedHandIndexes.delete(idx);
            else selectedHandIndexes.add(idx);
            renderHand();
          };
          container.appendChild(div);
        });
      }

      function seatForPlayer(pid) {
        const total = state.players.length;
        if (pid === myPlayerIndex) return 'self';

        const others = [];
        for (let i = 1; i < total; i++) others.push((myPlayerIndex + i) % total);

        const seats = { top: null, left: null, right: null };
        if (total === 2) seats.top = others[0];
        else if (total === 3) {
          seats.right = others[0];
          seats.left = others[1];
        } else {
          // 4
          seats.right = others[0];
          seats.top = others[1];
          seats.left = others[2];
        }

        if (seats.top === pid) return 'top';
        if (seats.left === pid) return 'left';
        if (seats.right === pid) return 'right';
        return null;
      }

      function fallbackSeatRect(seat) {
        const vw = window.innerWidth;
        const vh = window.innerHeight;

        if (seat === 'top') return { left: vw * 0.5 - 20, top: 40, width: 40, height: 60 };
        if (seat === 'left') return { left: 12, top: vh * 0.5 - 30, width: 40, height: 60 };
        if (seat === 'right') return { left: vw - 52, top: vh * 0.5 - 30, width: 40, height: 60 };

        return null;
      }

      function opponentAnchorRect(pid) {
        const seat = seatForPlayer(pid);

        if (seat === 'top') return getOpponentAnchorRectById('opponentTop', 'top');
        if (seat === 'left') return getOpponentAnchorRectById('opponentLeft', 'left');
        if (seat === 'right') return getOpponentAnchorRectById('opponentRight', 'right');

        return null;
      }

      function getOpponentAnchorRectById(rootId, seatFallback) {
        const root = document.getElementById(rootId);
        if (!root) return fallbackSeatRect(seatFallback);

        // tenta primeiro no container das cartas
        const cards = root.querySelector('.opponent-cards');
        const r1 = cards ? cards.getBoundingClientRect() : null;

        if (r1 && r1.width > 0 && r1.height > 0) {
          return {
            left: r1.left + r1.width * 0.5 - 20,
            top: r1.top + r1.height * 0.5 - 30,
            width: 40,
            height: 60,
          };
        }

        // fallback: usa o root todo (label + √°rea)
        const r2 = root.getBoundingClientRect();
        if (r2 && r2.width > 0 && r2.height > 0) {
          return {
            left: r2.left + r2.width * 0.5 - 20,
            top: r2.top + r2.height * 0.5 - 30,
            width: 40,
            height: 60,
          };
        }

        // fallback final (coordenada fixa na tela)
        return fallbackSeatRect(seatFallback);
      }

      // ==========================
      // MODO TESTE / DEBUG 1
      // ==========================
      window.debugScoreExample = function () {
        // sempre testar como Jogador 1
        myPlayerIndex = 0;

        const C = (rank, suit, joker = false) => ({ rank, suit, joker });

        // monta um state COMPLETO s√≥ em mem√≥ria, sem Firebase
        state = {
          mode: '1x1',
          variant: 'fechado',
          players: [
            { id: 0, name: 'Jogador 1', teamId: 0, hand: [] },
            { id: 1, name: 'Jogador 2', teamId: 1, hand: [] },
          ],
          teams: [
            { id: 0, name: 'Time 1', playerIndexes: [0], melds: [] },
            { id: 1, name: 'Time 2', playerIndexes: [1], melds: [] },
          ],
          currentPlayer: 0,
          stock: [],
          discard: [],
          deadPiles: [[], []],
          deadChunksTaken: [1, 1],
          deadChunksMax: [1, 1],
          hasDrawnThisTurn: true,
          finished: true, // j√° marca como fim de jogo
          winnerTeamId: 0, // vit√≥ria da equipe 1
          j2ConsecutiveTurns: 0,
          requiredDiscardCard: null,
        };

        const t1 = state.teams[0].melds;
        const t2 = state.teams[1].melds;

        // ---------- TIME 1 ----------

        // 1) Canastra REAL (2 ... A do mesmo naipe, sem coringa)
        t1.push([C('A', '‚ô£'), C('2', '‚ô£'), C('3', '‚ô£'), C('4', '‚ô£'), C('5', '‚ô£'), C('6', '‚ô£'), C('7', '‚ô£'), C('8', '‚ô£'), C('9', '‚ô£'), C('10', '‚ô£'), C('J', '‚ô£'), C('Q', '‚ô£'), C('K', '‚ô£')]);

        // 2) Canastra √ÅS A √ÅS (come√ßa e termina com √Ås)
        t1.push([C('A', '‚ô¶'), C('2', '‚ô¶'), C('3', '‚ô¶'), C('4', '‚ô¶'), C('5', '‚ô¶'), C('6', '‚ô¶'), C('7', '‚ô¶'), C('8', '‚ô¶'), C('9', '‚ô¶'), C('10', '‚ô¶'), C('J', '‚ô¶'), C('Q', '‚ô¶'), C('K', '‚ô¶'), C('A', '‚ô¶')]);

        // 3) Canastra LIMPA (sem coringa, sem √Ås no topo)
        t1.push([C('4', '‚ô•'), C('5', '‚ô•'), C('6', '‚ô•'), C('7', '‚ô•'), C('8', '‚ô•'), C('9', '‚ô•'), C('10', '‚ô•')]);

        // ---------- TIME 2 ----------

        // 4) Canastra SUJA (com coringa no meio)
        t2.push([C('5', '‚ô†'), C('6', '‚ô†'), C('7', '‚ô†'), C('JOKER', '‚òÖ', true), C('9', '‚ô†'), C('10', '‚ô†'), C('J', '‚ô†')]);

        // ningu√©m com carta na m√£o
        state.players[0].hand = [];
        state.players[1].hand = [];

        // limpa sele√ß√µes
        selectedHandIndexes.clear();
        selectedMeldTarget = null;

        // renderiza tudo e j√° for√ßa o placar
        renderAll();
        const scores = computeScores();
        renderScores(scores, state.winnerTeamId);

        showMessage('DEBUG: exemplo com canastra real, √Ås a √Ås, limpa e suja.');
      };

      // =====================================================
      // MODO TESTE 2: playground para sequ√™ncias e coringas
      // =====================================================
      window.debugSequenciasCoringas = function () {
        // garante que voc√™ √© o Jogador 1
        myPlayerIndex = 0;

        const C = (rank, suit, joker = false) => ({ rank, suit, joker });

        // state completo, mas jogo N√ÉO terminado
        state = {
          mode: '1x1',
          variant: 'fechado',
          players: [
            { id: 0, name: 'Jogador 1', teamId: 0, hand: [] },
            { id: 1, name: 'Jogador 2', teamId: 1, hand: [] },
          ],
          teams: [
            { id: 0, name: 'Time 1', playerIndexes: [0], melds: [] },
            { id: 1, name: 'Time 2', playerIndexes: [1], melds: [] },
          ],
          currentPlayer: 0,
          stock: [], // pode deixar vazio, foco √© mexer nos jogos
          discard: [], // se quiser testar compra do descarte, p√µe carta aqui
          deadPiles: [[], []],
          deadChunksTaken: [0, 0],
          deadChunksMax: [1, 1],
          hasDrawnThisTurn: true, // j√° ‚Äúcomprou‚Äù, pode s√≥ baixar / mexer jogo
          finished: false, // N√ÉO terminou
          winnerTeamId: null,
          j2ConsecutiveTurns: 0,
          requiredDiscardCard: null,
        };

        const t1 = state.teams[0].melds;
        const t2 = state.teams[1].melds;

        // ---------------- TIME 1 (seus jogos) ----------------

        // 1) A‚ô£ 2‚ô£ 3‚ô£ 4‚ô£ 5‚ô£ 6‚ô£ 7‚ô£  -> 2 N√ÉO √© coringa aqui (A-2-3)
        t1.push([C('A', '‚ô£'), C('2', '‚ô£'), C('3', '‚ô£'), C('4', '‚ô£'), C('5', '‚ô£'), C('6', '‚ô£'), C('7', '‚ô£')]);

        // 2) A‚ô• JOKER 3‚ô• 4‚ô• 5‚ô• -> buraco A‚Äì3 preenchido por coringa (suja)
        t1.push([C('A', '‚ô•'), C('JOKER', '‚òÖ', true), C('3', '‚ô•'), C('4', '‚ô•'), C('5', '‚ô•')]);

        // 3) 8‚ô¶ 9‚ô¶ JOKER J‚ô¶ Q‚ô¶ -> coringa no meio de sequ√™ncia normal
        t1.push([C('8', '‚ô¶'), C('9', '‚ô¶'), C('JOKER', '‚òÖ', true), C('J', '‚ô¶'), C('Q', '‚ô¶')]);

        // 4) Q‚ô† K‚ô† A‚ô† -> sequ√™ncia com √Ås alto
        t1.push([C('Q', '‚ô†'), C('K', '‚ô†'), C('A', '‚ô†')]);

        // ---------------- TIME 2 (refer√™ncia) ----------------

        // 5) 4‚ô† 5‚ô† 6‚ô† 7‚ô† 8‚ô† 9‚ô† 10‚ô† -> canastra limpa simples pra comparar
        t2.push([C('4', '‚ô†'), C('5', '‚ô†'), C('6', '‚ô†'), C('7', '‚ô†'), C('8', '‚ô†'), C('9', '‚ô†'), C('10', '‚ô†')]);

        // 6) A‚ô¶ 2‚ô¶ 3‚ô¶ 4‚ô¶ 5‚ô¶ 6‚ô¶ 7‚ô¶ 8‚ô¶ 9‚ô¶ 10‚ô¶
        t2.push([C('A', '‚ô¶'), C('2', '‚ô¶'), C('3', '‚ô¶'), C('4', '‚ô¶'), C('5', '‚ô¶'), C('6', '‚ô¶'), C('7', '‚ô¶'), C('8', '‚ô¶'), C('9', '‚ô¶'), C('10', '‚ô¶')]);

        // ---------------- CARTAS NA M√ÉO ----------------

        // Sua m√£o: v√°rios 2 e coringas pra voc√™ brincar de mover
        state.players[0].hand = [C('2', '‚ô•'), C('2', '‚ô†'), C('2', '‚ô¶'), C('JOKER', '‚òÖ', true), C('5', '‚ô£'), C('K', '‚ô¶'), C('A', '‚ô£')];

        // m√£o do jogador 2 s√≥ pra n√£o ficar vazia
        state.players[1].hand = [C('7', '‚ô†'), C('8', '‚ô†'), C('9', '‚ô†')];

        // limpa sele√ß√µes
        selectedHandIndexes.clear();
        selectedMeldTarget = null;

        renderAll();
        showMessage('DEBUG: playground de sequ√™ncias e coringas carregado.');
      };

      // =====================================================
      // MODO TESTE 3: comprar N cartas do monte (r√°pido p/ testar)
      // Uso no console:
      //   await debugBuyStock(30)                    // compra 30 para voc√™ (myPlayerIndex)
      //   await debugBuyStock(30, { playerId: 1 })   // compra 30 para o jogador 2
      //   await debugBuyStock(30, { bypassTurn: true }) // ignora vez (default)
      // =====================================================
      window.debugBuyStock = async function (n = 30, opts = {}) {
        try {
          const count = Math.max(0, Number(n) || 0);
          if (!state) {
            showMessage('DEBUG: sem partida/state carregado.');
            return;
          }
          if (state.finished) {
            showMessage('DEBUG: fim de jogo.');
            return;
          }

          const bypassTurn = opts.bypassTurn !== false; // default TRUE
          if (!bypassTurn && state.currentPlayer !== myPlayerIndex) {
            showMessage('DEBUG: n√£o √© sua vez.');
            return;
          }

          const playerId = opts.playerId ?? myPlayerIndex ?? state.currentPlayer;
          const p = state.players?.[playerId];
          if (!p) {
            showMessage('DEBUG: playerId inv√°lido.');
            return;
          }

          let drew = 0;
          for (let i = 0; i < count; i++) {
            if (!state.stock.length) {
              if (!recycleDeadToStockIfPossible() || !state.stock.length) break;
            }
            const c = state.stock.pop();
            ensureCardId(c);
            p.hand.push(c);
            drew++;
          }

          sortHand(p.hand);

          // deixa o jogo "comprado" pra evitar bloqueios na UI
          if (playerId === state.currentPlayer) state.hasDrawnThisTurn = true;

          // registra a√ß√£o s√≥ pra sincronizar (e n√£o disparar anima√ß√µes normais)
          state.lastAction = { id: newActionId(), type: 'debugDrawStock', playerId, count: drew, ts: Date.now() };
          ignoreOwnActionId = state.lastAction.id;

          renderAll();
          await commitState();

          showMessage(`DEBUG: jogador ${playerId} comprou ${drew} carta(s) do monte.`);
        } catch (e) {
          console.error(e);
          showMessage('DEBUG: erro ao comprar cartas (veja console).');
        }
      };

      function renderOpponentHands() {
        const top = document.getElementById('opponentTop');
        top.innerHTML = '';
        const left = document.getElementById('opponentLeft');
        left.innerHTML = '';
        const right = document.getElementById('opponentRight');
        right.innerHTML = '';

        const total = state.players.length;
        const seats = { top: null, left: null, right: null };
        const others = [];
        for (let i = 1; i < total; i++) others.push((myPlayerIndex + i) % total);

        if (total === 2) seats.top = others[0];
        else if (total === 3) {
          seats.right = others[0];
          seats.left = others[1];
        } else {
          seats.right = others[0];
          seats.top = others[1];
          seats.left = others[2];
        }

        [
          { idx: seats.top, el: top },
          { idx: seats.left, el: left },
          { idx: seats.right, el: right },
        ].forEach((obj) => {
          if (obj.idx === null) return;
          const p = state.players[obj.idx];
          const label = document.createElement('div');
          label.className = 'opponent-label';
          label.textContent = `${p.name} (${p.hand.length})`;
          obj.el.appendChild(label);

          const cardsDiv = document.createElement('div');
          cardsDiv.className = 'opponent-cards';
          const count = Math.min(p.hand.length, 12);
          for (let i = 0; i < count; i++) {
            const cdata = p.hand[i]; // existe no state hoje
            const c = document.createElement('div');
            c.className = 'opponent-card-back ' + (cdata?.back === 'blue' ? 'back-blue' : 'back-red');
            cardsDiv.appendChild(c);
          }

          obj.el.appendChild(cardsDiv);
        });
      }

      function renderMelds() {
        const m1 = document.getElementById('meldsP1');
        m1.innerHTML = '';
        const m2 = document.getElementById('meldsP2');
        m2.innerHTML = '';
        let s1 = 0,
          s2 = 0;
        state.teams.forEach((t, i) => {
          const info = computeTeamMeldScore(t);
          if (i === 0) s1 = info.total;
          else s2 = info.total;
          const target = i === 0 ? m1 : m2;
          t.melds.forEach((meld, midx) => {
            const div = document.createElement('div');
            div.className = 'meld-line';
            const key = t.id + ':' + midx;
            div.dataset.meldKey = key;
            if (selectedMeldTarget === key) div.classList.add('selected-meld');

            const row = document.createElement('div');
            row.className = 'meld-line-cards';
            const mInfo = classifyMeldForUi(meld);

            meld.forEach((c, cidx) => {
              if (mInfo.kind !== 'simple' && cidx === meld.length - 1) return;
              const minic = document.createElement('div');
              minic.className = 'carta mini ' + (c.joker ? 'joker-card' : c.suit === '‚ô•' || c.suit === '‚ô¶' ? 'hearts' : 'spades');
              minic.dataset.cardIndex = cidx;
              minic.innerHTML = c.joker ? `<div class="carta-canto">‚òÖ</div>` : `<div class="carta-canto">${c.rank}${c.suit}</div>`;

              const me = state.players[myPlayerIndex];
              const myTurn = !state.finished && state.currentPlayer === myPlayerIndex;

              if (me && t.id === me.teamId && myTurn && state.hasDrawnThisTurn && isMovableTwoOrJoker(c)) {
                minic.classList.add('wild-pickable');
                if (movingWild && movingWild.fromTeamId === t.id && movingWild.fromMeldIndex === midx && movingWild.fromCardIndex === cidx) {
                  minic.classList.add('wild-picked');
                }

                minic.onclick = (ev) => {
                  ev.stopPropagation(); // n√£o troca selectedMeldTarget ao clicar na carta
                  pickWildFromMeld(t.id, midx, cidx);
                };
              }

              row.appendChild(minic);
            });

            if (mInfo.kind !== 'simple') {
              const last = meld[meld.length - 1];
              const closed = document.createElement('div');
              closed.className = 'carta mini canastra-fechada ' + (last.joker ? 'joker-card' : last.suit === '‚ô•' || last.suit === '‚ô¶' ? 'hearts' : 'spades');
              closed.dataset.cardIndex = meld.length - 1;
              closed.innerHTML = last.joker ? `<div class="carta-canto">‚òÖ</div>` : `<div class="carta-canto">${last.rank}${last.suit}</div>`;

              const me = state.players[myPlayerIndex];
              const myTurn = !state.finished && state.currentPlayer === myPlayerIndex;

              if (me && t.id === me.teamId && myTurn && state.hasDrawnThisTurn && isMovableTwoOrJoker(last)) {
                closed.classList.add('wild-pickable');
                if (movingWild && movingWild.fromTeamId === t.id && movingWild.fromMeldIndex === midx && movingWild.fromCardIndex === meld.length - 1) {
                  closed.classList.add('wild-picked');
                }

                closed.onclick = (ev) => {
                  ev.stopPropagation();
                  pickWildFromMeld(t.id, midx, meld.length - 1);
                };
              }

              row.appendChild(closed);
            }

            const meta = document.createElement('div');
            meta.className = 'meld-meta';
            meta.innerHTML = mInfo.base + (mInfo.tag ? ` <span class="meld-tag ${mInfo.tag.cls}">${mInfo.tag.text}</span>` : '');

            div.appendChild(row);
            div.appendChild(meta);
            div.onclick = () => {
              selectedMeldTarget = selectedMeldTarget === key ? null : key;
              showMessage(selectedMeldTarget ? 'Jogo selecionado.' : 'Sele√ß√£o limpa.');
              renderMelds();
            };
            target.appendChild(div);
          });
        });
        document.getElementById('scoreTeam1').textContent = s1;
        document.getElementById('scoreTeam2').textContent = s2;
      }

      function renderScores(scores, winner) {
        document.getElementById('scoreSection').style.display = 'flex';
        const board = document.getElementById('scoreBoard');
        board.innerHTML = '';
        scores.sort((a, b) => b.score - a.score);
        scores.forEach((s) => {
          const bonusCanastra = (s.sujaBonus + s.limpaBonus + s.realBonus + s.asasBonus) || 0;
          const batida = s.batidaBonus || 0;
          const mortoB = s.mortoBonus || 0;
          const mortoP = s.mortoPenalty || 0;

          board.innerHTML += `<div style="margin-bottom:10px; border-bottom:1px solid #333; padding-bottom:8px;">
              <strong style="color:${s.team.id === winner ? '#facc15' : '#fff'}">${s.team.name}</strong>: <strong>${s.score}</strong> pts
              <div style="font-size:11px; color:#aaa; margin-top:4px; line-height:1.35;">
                <div>Jogos (cartas): +${s.meldPoints}</div>
                <div>B√¥nus canastras: +${bonusCanastra}
                  <span style="color:#888;">(suja ${s.sujaBonus}, limpa ${s.limpaBonus}, real ${s.realBonus}, √°s‚Äë√°s ${s.asasBonus})</span>
                </div>
                <div>Batida: +${batida}</div>
                <div>Morto: +${mortoB} / -${mortoP}</div>
                <div>M√£o: -${s.handPenalty}</div>
              </div>
            </div>`;
        });
      }

      function showMessage(msg) {
        document.getElementById('message').textContent = msg;
      }

      function seatElForPlayer(pid) {
        if (pid === myPlayerIndex) return document.getElementById('handContainer');

        const total = state.players.length;
        const others = [];
        for (let i = 1; i < total; i++) others.push((myPlayerIndex + i) % total);

        // mesmo mapeamento do renderOpponentHands()
        if (total === 2) return pid === others[0] ? document.getElementById('opponentTop') : null;

        if (total === 3) {
          if (pid === others[0]) return document.getElementById('opponentRight');
          if (pid === others[1]) return document.getElementById('opponentLeft');
          return null;
        }

        if (pid === others[0]) return document.getElementById('opponentRight');
        if (pid === others[1]) return document.getElementById('opponentTop');
        if (pid === others[2]) return document.getElementById('opponentLeft');
        return null;
      }

      function seatPointRect(pid) {
        const el = seatElForPlayer(pid);
        if (!el) return null;
        const r = el.getBoundingClientRect();
        // um ‚Äúponto‚Äù de onde sai/entra carta no seat
        return { left: r.left + r.width * 0.5 - 20, top: r.top + 18, width: 40, height: 60 };
      }

      async function playRemoteAction(a) {
        if (!state || !a) return;

        const stockEl = document.querySelector('#drawStockBtn .pile-card');
        const discardEl = document.getElementById('discardFace');
        const dead0El = document.getElementById('mortoSlot0');
        const dead1El = document.getElementById('mortoSlot1');

        const stockRect = stockEl ? getRect(stockEl) : null;
        const discardRect = discardEl ? getRect(discardEl) : null;

        const handRect = opponentAnchorRect(a.playerId);
        if (!handRect) return;

        const fallbackCard = a.card || { rank: '‚òÖ', suit: '‚òÖ', joker: true, id: `rf_${Date.now()}` };

        // helper pra ‚Äúcair‚Äù v√°rias com offsets
        const dropRects = (baseRect, count) => {
          const out = [];
          for (let i = 0; i < count; i++) {
            out.push({ ...baseRect, left: baseRect.left - i * 10, top: baseRect.top + i * 2 });
          }
          return out;
        };

        if (a.type === 'drawStock') {
          if (stockRect) await flyRectToRect(fallbackCard, stockRect, handRect, 'back');
          impactAtRect(handRect); // ‚úÖ era toRect inexistente
          return;
        }

        if (a.type === 'drawDiscard') {
          if (discardRect) await flyRectToRect(fallbackCard, discardRect, handRect, 'front');
          impactAtRect(handRect); // ‚úÖ era toRect inexistente
          return;
        }

        if (a.type === 'discard') {
          if (discardRect) await flyRectToRect(fallbackCard, handRect, discardRect, 'front');
          impactAtRect(discardRect); // ‚úÖ fa√≠sca onde caiu (no lixo)
          return;
        }

        if (a.type === 'takeDead') {
          const fromEl = a.deadIndex === 1 || a.teamId === 1 ? dead1El : dead0El;
          const fromRect = fromEl ? getRect(fromEl) : null;
          if (fromRect) await flyRectToRect(fallbackCard, fromRect, handRect, 'back');
          impactAtRect(handRect); // ‚úÖ
          return;
        }

        if (a.type === 'meldNew') {
          // ‚úÖ tenta cair no MELD CERTO se veio meldIndex
          let base = null;

          if (a.meldIndex != null && a.teamId != null) {
            const key = `${a.teamId}:${a.meldIndex}`;
            base = meldDropRect(key, 0); // usa a trilha do jogo
          }

          // fallback se ainda n√£o existir no DOM (raro)
          if (!base) {
            const container = document.getElementById((a.teamId ?? 0) === 0 ? 'meldsP1' : 'meldsP2');
            if (!container) return;
            const tr = container.getBoundingClientRect();
            base = { left: tr.left + tr.width - 30, top: tr.top + 10, width: 22, height: 30 };
          }

          const cards = a.cards && a.cards.length ? a.cards : [fallbackCard];
          const targets = dropRects(base, cards.length);

          // ‚úÖ ao mesmo tempo + fa√≠sca por carta
          await Promise.all(
            cards.map((c, i) => {
              c.id ||= `rm_${Date.now()}_${i}`;
              const toRect = targets[i];
              return flyRectToRect(c, handRect, toRect, 'front').then(() => impactAtRect(toRect));
            })
          );

          return;
        }

        if (a.type === 'meldExtend') {
          if (a.meldIndex == null || a.teamId == null) return;

          const key = `${a.teamId}:${a.meldIndex}`;
          const base = meldDropRect(key, 0);
          if (!base) return;

          const cards = a.cards && a.cards.length ? a.cards : [fallbackCard];
          const targets = dropRects(base, cards.length);

          // ‚úÖ ao mesmo tempo + fa√≠sca
          await Promise.all(
            cards.map((c, i) => {
              c.id ||= `re_${Date.now()}_${i}`;
              const toRect = targets[i];
              return flyRectToRect(c, handRect, toRect, 'front').then(() => impactAtRect(toRect));
            })
          );

          return;
        }

        if (a.type === 'meldMoveWild') {
          if (a.teamId == null || a.fromMeldIndex == null || a.toMeldIndex == null) return;

          const fromRect = meldCardsRect(a.teamId, a.fromMeldIndex) || meldDropRect(`${a.teamId}:${a.fromMeldIndex}`, 0);
          const toRect = meldDropRect(`${a.teamId}:${a.toMeldIndex}`, 0) || meldCardsRect(a.teamId, a.toMeldIndex);
          if (!fromRect || !toRect) return;

          const card = a.card || { rank: '‚òÖ', suit: '‚òÖ', joker: true, id: `mw_${Date.now()}` };
          await flyRectToRect(card, fromRect, toRect, 'front');
          impactAtRect(toRect);
          return;
        }
      }

      onSnapshot(gameRef, async (snap) => {
        if (!snap.exists()) {
          state = null;
          selectedHandIndexes.clear();
          document.getElementById('configSection').style.display = 'block';
          document.getElementById('gameSection').style.display = 'none';

          resetCanastraSfxMemory();

          return;
        }

        const newState = JSON.parse(snap.data().stateJson);
        state = newState;

        // evita ficar ‚Äúsegurando‚Äù carta mov√≠vel depois de atualiza√ß√£o remota
        movingWild = null;

        syncCanastraSfxFromState();

        selectedHandIndexes.clear();
        document.getElementById('configSection').style.display = 'none';
        document.getElementById('gameSection').style.display = 'flex';

        renderAll();
        startTurnTimerIfNeeded();

        const a = state.lastAction;
        if (!a || a.id === lastSeenActionId) return;

        lastSeenActionId = a.id;

        // evita ‚Äúre-animar‚Äù no pr√≥prio client (porque voc√™ j√° animou localmente)
        if (a.id === ignoreOwnActionId) {
          ignoreOwnActionId = null;
          return;
        }

        // anima pros outros
        await playRemoteAction(a);
      });

      document.getElementById('startBtn').onclick = () => {
        startGame(
          document.getElementById('modeSelect').value,
          [document.getElementById('p1Name').value, document.getElementById('p2Name').value, document.getElementById('p3Name').value, document.getElementById('p4Name').value],
          document.getElementById('variantSelect').value
        );
      };

      document.getElementById('localPlayerSelect').onchange = (e) => {
        myPlayerIndex = parseInt(e.target.value);
        if (state) renderAll();
      };
      document.getElementById('drawStockBtn').onclick = drawFromStock;
      document.getElementById('drawDiscardBtn').onclick = drawFromDiscard;
      document.getElementById('meldBtn').onclick = makeMeldFromSelection;
      document.getElementById('moveWildBtn').onclick = movePickedWildToSelectedMeld;
      document.getElementById('discardBtn').onclick = discardSelectedCard;
      document.getElementById('takeDeadBtn').onclick = takeDead;
      document.getElementById('endGameBtn').onclick = () => deleteDoc(gameRef);
      document.getElementById('closeScoreBtn').onclick = () => (document.getElementById('scoreSection').style.display = 'none');
    </script>
  </body>
</html>
