<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <title>Buraco ‚Äì Firebase</title>
    <link rel="manifest" href="manifest.webmanifest" />
    <meta name="theme-color" content="#020617" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="icon-32.png" />
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png" />
    <link rel="apple-touch-icon" sizes="192x192" href="icon-192.png" />

    <style>
      :root {
        --bg-main: #020617;
        --bg-panel-soft: rgba(15, 23, 42, 0.92);
        --accent: #22c55e;
        --accent-strong: #16a34a;
        --text-main: #e5e7eb;
        --text-muted: #9ca3af;
      }

      * {
        box-sizing: border-box;
        user-select: none;
        -webkit-tap-highlight-color: transparent; /* Remove piscar azul no toque */
      }

      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%; /* Fallback */
        height: 100dvh; /* Altura din√¢mica real do mobile */
        overflow: hidden; /* Trava scroll da p√°gina inteira */
        background: #020617;
        font-family: system-ui, -apple-system, sans-serif;
      }

      .app {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
      }

      /* TELA DE CONFIG (Scroll√°vel se necess√°rio) */
      #configSection {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        background: radial-gradient(circle at center, #064e3b 0%, #020617 100%);
        display: flex;
        flex-direction: column;
        justify-content: center;
      }

      /* ESTILOS DE CONFIGURA√á√ÉO */
      .section {
        background: rgba(15, 23, 42, 0.95);
        border-radius: 12px;
        padding: 20px;
        border: 1px solid #1f2937;
        max-width: 400px;
        margin: 0 auto;
        width: 100%;
      }
      .section h2 {
        margin-top: 0;
        color: #fff;
      }
      input,
      select {
        width: 100%;
        padding: 10px;
        margin-bottom: 10px;
        border-radius: 8px;
        border: 1px solid #4b5563;
        background: rgba(0, 0, 0, 0.3);
        color: white;
      }
      button {
        width: 100%;
        padding: 12px;
        border-radius: 99px;
        border: none;
        font-weight: bold;
        cursor: pointer;
        background: var(--accent-strong);
        color: white;
        margin-top: 5px;
      }

      /* ================= JOGO ================= */
      #gameSection {
        flex: 1;
        display: none; /* JS ativa display:flex */
        flex-direction: column;
        height: 100%;
        width: 100%;
        overflow: hidden;
        background: radial-gradient(circle at center, #15803d 0%, #14532d 100%);
      }

      .board {
        flex: 1;
        display: flex;
        flex-direction: column;
        position: relative;
        overflow: hidden; /* Garante que nada saia da mesa */
        padding-bottom: 0;
      }

      /* -- TOPO -- */
      .board-top {
        padding: 10px;
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        height: 50px; /* Altura fixa para n√£o variar */
        z-index: 20;
      }
      .current-player-chip {
        background: rgba(0, 0, 0, 0.5);
        padding: 4px 10px;
        border-radius: 20px;
        color: #fff;
        font-size: 12px;
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .current-dot {
        width: 8px;
        height: 8px;
        background: #4ade80;
        border-radius: 50%;
      }

      /* Mortos */
      .morto-area {
        display: flex;
        gap: 8px;
      }
      .morto-container {
        position: relative;
        width: 30px;
        height: 44px;
        opacity: 1;
      }

      .morto-label {
        position: absolute;
        bottom: -12px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 9px;
        color: #e5e7eb;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
      }

      .morto-container.used {
        opacity: 0;
      }
      .morto-card-back {
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 4px;
        background: #991b1b;
        border: 1px solid #fff;
      }
      .morto-card-back.offset {
        transform: translate(3px, -3px);
      }

      /* -- OPONENTES -- */
      .opponent-hand {
        position: absolute;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
        pointer-events: none;
        font-size: 10px;
        color: #e5e7eb;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
      }

      /* TOPO ‚Äì leque horizontal */
      .opponent-hand-top {
        top: 26px;
        left: 50%;
        transform: translateX(-50%);
      }

      /* LATERAIS ‚Äì ficam no meio da mesa */
      .opponent-hand-left,
      .opponent-hand-right {
        top: 50%;
        transform: translateY(-50%);
      }

      .opponent-hand-left {
        left: 10px;
        align-items: center;
      }

      .opponent-hand-right {
        right: 10px;
        align-items: center;
      }

      /* Nome + qtd de cartas */
      .opponent-label {
        font-size: 11px;
        opacity: 0.85;
        background: rgba(15, 23, 42, 0.9);
        padding: 2px 6px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.5);
      }

      .opponent-cards {
        display: flex;
        gap: 3px;
      }

      /* Verso das cartas dos oponentes */
      .opponent-card-back {
        width: 30px;
        height: 44px;
        border-radius: 6px;
        background: #7f1d1d;
        border: 1px solid #3d0a0a;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.7);
      }

      /* TOPO ‚Äì sobreposi√ß√£o leve, tipo leque */
      .opponent-hand-top .opponent-card-back {
        margin-left: -14px;
      }
      .opponent-hand-top .opponent-card-back:first-child {
        margin-left: 0;
      }

      /* LATERAIS ‚Äì coluna, levemente ‚Äújuntas‚Äù */
      .opponent-hand-left .opponent-cards,
      .opponent-hand-right .opponent-cards {
        flex-direction: column;
        align-items: center;
      }

      .opponent-hand-left .opponent-card-back,
      .opponent-hand-right .opponent-card-back {
        margin-top: -12px;
      }

      .opponent-hand-left .opponent-card-back:first-child,
      .opponent-hand-right .opponent-card-back:first-child {
        margin-top: 0;
      }

      /* Rota√ß√£o das laterais (como no layout antigo) */
      .opponent-hand-left .opponent-card-back {
        transform: rotate(90deg);
        transform-origin: center center;
      }

      .opponent-hand-right .opponent-card-back {
        transform: rotate(-90deg);
        transform-origin: center center;
      }

      /* Laterais */
      .opponent-hand-left {
        top: 45%;
        left: 5px;
        transform: translateY(-50%);
      }
      .opponent-hand-left .opponent-card-back {
        transform: rotate(90deg);
        margin-bottom: -15px;
      }

      .opponent-hand-right {
        top: 45%;
        right: 5px;
        transform: translateY(-50%);
      }
      .opponent-hand-right .opponent-card-back {
        transform: rotate(-90deg);
        margin-bottom: -15px;
      }

      /* -- JOGOS BAIXADOS (√ÅREA DE MELDS) -- */
      .board-melds {
        flex: 0 0 auto; /* s√≥ o tamanho dos conte√∫dos */
        min-height: 60px;
        max-width: 760px;
        margin: 70px auto 4px; /* centraliza e deixa espa√ßo do topo */
        padding: 6px 10px;
        display: flex;
        gap: 20px; /* espa√ßo entre Time 1 e Time 2 */
        background: rgba(0, 0, 0, 0.15);
        border-radius: 8px;
        overflow: visible;
      }

      /* bloco de cada equipe dentro da faixa de jogos */
      .board-melds .grow {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        background: rgba(15, 23, 42, 0.85);
        border-radius: 10px;
        padding: 6px 10px;
      }

      /* segundo bloco (Time 2) com tra√ßo no meio */
      .board-melds .grow + .grow {
        padding-left: 16px !important;
        border-left: 1px dashed rgba(148, 163, 184, 0.5) !important;
      }

      /* cabe√ßalho com nome do time + pontos */
      .meld-title {
        display: flex;
        justify-content: space-between;
        font-size: 11px;
        color: #cbd5e1;
        margin-bottom: 4px;
      }

      /* √°rea onde os jogos ficam lado a lado */
      .meld-container {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        align-content: flex-start;
      }

      /* bloco de UM jogo espec√≠fico */
      .meld-line {
        background: rgba(0, 0, 0, 0.45);
        border-radius: 6px;
        padding: 4px 6px 6px;
        display: flex;
        flex-direction: column; /* cards em cima, texto embaixo */
        align-items: center;
        cursor: pointer;
        border: 1px solid transparent;
        flex: 0 1 auto;
        min-width: 140px; /* largura m√≠nima de cada jogo */
      }

      .meld-line.selected-meld {
        border-color: #facc15;
        background: rgba(250, 204, 21, 0.2);
      }

      /* trilho das mini-cartas ‚Äì HORIZONTAL */
      .meld-line-cards {
        display: flex;
        align-items: center;
        height: 42px;
      }

      /* legenda (Jogo simples, Canastra limpa, etc.) */
      .meld-meta {
        font-size: 10px;
        color: #e5e7eb;
        margin-top: 4px;
        text-align: center;
      }

      /* -- MEIO DA MESA (MONTE E LIXO) -- */
      .board-middle {
        display: flex;
        justify-content: center;
        gap: 30px;
        align-items: center;
        padding: 10px 0;
        flex-shrink: 0;
        z-index: 5;
      }

      .pile-area {
        display: flex;
        flex-direction: column;
        align-items: center;
        position: relative;
        cursor: pointer;
      }

      .pile-card {
        width: 55px;
        height: 80px;
        border-radius: 6px;
        background: #b91c1c;
        border: 2px solid #fff;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .pile-card.discard-pile {
        background: transparent;
        border: 2px dashed rgba(255, 255, 255, 0.4);
      }

      .discard-face {
        width: 100%;
        height: 100%;
        background: #f3f4f6;
        border-radius: 4px;
        color: #000;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        padding: 2px;
        font-weight: bold;
        font-size: 12px;
      }

      .pile-info {
        font-size: 10px;
        color: #fff;
        background: rgba(0, 0, 0, 0.7);
        padding: 2px 6px;
        border-radius: 10px;
        margin-top: -8px;
        z-index: 10;
      }

      /* -- √ÅREA DO JOGADOR (RODAP√â) -- */
      .player-interface {
        background: linear-gradient(to top, rgba(2, 6, 23, 0.95) 0%, rgba(2, 6, 23, 0.8) 60%, transparent 100%);
        padding: 5px 10px 10px 10px;
        display: flex;
        flex-direction: column;
        gap: 5px;
        z-index: 50;
        width: 100%;
        margin-top: auto;
      }

      #message {
        text-align: center;
        font-size: 11px;
        color: #facc15;
        font-weight: bold;
        height: 15px;
        text-shadow: 0 1px 2px black;
      }

      .player-actions {
        display: flex;
        justify-content: center;
        gap: 8px;
      }

      .player-actions button {
        width: auto;
        padding: 8px 12px;
        font-size: 11px;
        margin: 0;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      #meldBtn {
        background: #059669;
      }

      #discardBtn {
        background: #be123c;
      }

      #takeDeadBtn {
        background: #4f46e5;
      }

      #endGameBtn {
        background: #333;
        padding: 8px;
      }

      /* M√ÉO DO JOGADOR - LEQUE */
      .hand-container {
        display: flex;
        justify-content: center;
        overflow-x: auto;
        padding: 15px 10px 5px 10px;
        min-height: 90px;
      }

      .cards-row {
        display: flex;
        align-items: flex-end;
        padding-right: 20px; /* espa√ßo extra pra √∫ltima carta */
      }

      /* CARTA PADR√ÉO */
      .carta {
        width: 60px;
        height: 90px;
        background: #fff;
        border-radius: 5px;
        border: 1px solid #000;
        position: relative;
        flex-shrink: 0;
        cursor: pointer;
        box-shadow: -1px 1px 4px rgba(0, 0, 0, 0.3);
        margin-right: -30px; /* sobreposi√ß√£o leque */
        transition: transform 0.1s, margin-right 0.1s;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        padding: 2px 4px;
        font-size: 14px;
        font-weight: bold;
      }

      .carta:last-child {
        margin-right: 0;
      }

      .carta:hover,
      .carta.selected {
        transform: translateY(-15px);
        margin-right: 0;
        z-index: 100;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
      }

      .carta.selected {
        border: 2px solid #facc15;
      }

      .hearts,
      .diamonds {
        color: #dc2626;
      }

      .spades,
      .clubs,
      .joker-card {
        color: #000;
      }

      .carta-icone {
        font-size: 20px;
        align-self: flex-end;
        line-height: 1;
      }

      /* MINI CARTA (NA MESA) */
      .carta.mini {
        width: 28px;
        height: 40px;
        margin-right: -14px;
        margin-bottom: 0;
        font-size: 10px;
        padding: 1px;
      }

      .carta.mini .carta-icone {
        font-size: 12px;
      }

      .carta.mini.canastra-fechada {
        transform: rotate(90deg);
        margin-right: -8px;
        margin-bottom: -8px;
      }

      /* ============================
         MOBILE (largura <= 768px)
         ============================ */
      @media (max-width: 768px) {
        body {
          font-size: 12px;
        }

        .board-top {
          padding: 6px;
          height: 44px;
        }

        /* oponente do topo desce um pouco */
        .opponent-hand-top {
          top: 52px;
        }

        .board-melds {
          max-width: 100%;
          margin: 10px 6px 4px;
          padding: 4px 6px;
          gap: 10px;
          border-radius: 6px;
          min-height: 50px;
        }

        .board-melds .grow {
          padding: 4px 6px;
        }

        .meld-title {
          font-size: 10px;
        }

        .meld-line {
          min-width: 120px;
          padding: 3px 4px 5px;
        }

        .meld-line-cards {
          height: 34px;
        }

        .meld-meta {
          font-size: 9px;
        }

        .board-middle {
          gap: 20px;
          padding: 6px 0;
        }

        .pile-card {
          width: 45px;
          height: 65px;
        }

        .pile-info {
          font-size: 9px;
        }

        .morto-container {
          width: 26px;
          height: 38px;
        }

        .morto-card-back {
          border-radius: 4px;
        }

        .opponent-card-back {
          width: 26px;
          height: 38px;
          border-radius: 5px;
        }

        .hand-container {
          padding: 10px 6px 4px 6px;
          min-height: 80px;
        }

        .carta {
          width: 50px;
          height: 75px;
          margin-right: -25px;
          font-size: 12px;
        }

        .carta-icone {
          font-size: 16px;
        }

        .player-actions {
          gap: 6px;
        }

        .player-actions button {
          padding: 6px 10px;
          font-size: 10px;
        }

        #scoreSection .section {
          width: 94%;
          max-width: 380px;
        }
      }

      /* PLACAR OVERLAY */
      #scoreSection {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.95);
        z-index: 200;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      /* ============================
   AJUSTE MOBILE (largura <= 768px)
   ============================ */
      @media (max-width: 768px) {
        /* deixa a mesa poder rolar um pouco em vez de cortar */
        .board {
          overflow-y: auto;
          overflow-x: hidden;
        }

        /* faixa dos jogos mais compacta e sem scroll interno */
        .board-melds {
          flex: 0 0 auto;
          max-width: 100%;
          margin: 8px 6px 2px;
          padding: 4px 6px;
          gap: 10px;
          min-height: 50px;
          overflow: visible;
        }

        .board-melds .grow {
          padding: 4px 6px;
        }

        .meld-title {
          font-size: 10px;
        }

        .meld-line {
          min-width: 110px;
          padding: 3px 4px 4px;
        }

        /* cartas dos jogos bem baixinhas pra caber tudo */
        .meld-line-cards {
          display: flex;
          align-items: center;
          height: 30px;
        }

        .carta.mini {
          width: 22px;
          height: 32px;
          margin-right: -10px;
          font-size: 9px;
        }

        .meld-meta {
          font-size: 9px;
        }
      }

      /* container da mesa */
      .mesa {
        position: relative;
        height: 100vh;
        overflow: hidden;
      }

      /* m√£o do jogador ativo */
      .mao-ativa {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        bottom: 80px; /* altura aproximada da barra de bot√µes */
        display: flex;
        gap: 0.4rem;
        z-index: 15; /* menor que a barra, maior que o resto */
      }

      /* barra de bot√µes */
      .barra-acoes {
        position: absolute;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 20;
      }

      @media (max-height: 500px) {
        .pilha-compra .carta,
        .pilha-descarte .carta {
          transform: scale(0.8); /* diminui as cartas */
        }

        .area-centro {
          margin-bottom: 4.5rem; /* libera espa√ßo pra m√£o */
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <div id="configSection">
        <div class="section">
          <div class="section-header">
            <h2>Buraco Alpha</h2>
            <small>Configura√ß√£o da sala</small>
          </div>
          <div style="margin-top: 15px; display: flex; flex-direction: column; gap: 10px">
            <label>
              Modo
              <select id="modeSelect">
                <option value="1x1">1x1</option>
                <option value="2x2">2x2</option>
                <option value="1x2">1x2</option>
                <option value="1x1_duploMorto">1x1 Humilha√ß√£o</option>
              </select>
            </label>
            <label>
              Regra
              <select id="variantSelect">
                <option value="aberto">Aberto</option>
                <option value="fechado">Fechado</option>
              </select>
            </label>
            <label>
              Sou
              <select id="localPlayerSelect">
                <option value="0">Jogador 1</option>
                <option value="1">Jogador 2</option>
                <option value="2">Jogador 3</option>
                <option value="3">Jogador 4</option>
              </select>
            </label>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px">
              <input id="p1Name" value="Jogador 1" placeholder="Nome J1" />
              <input id="p2Name" value="Jogador 2" placeholder="Nome J2" />
              <input id="p3Name" value="Jogador 3" placeholder="Nome J3" />
              <input id="p4Name" value="Jogador 4" placeholder="Nome J4" />
            </div>

            <button id="startBtn" style="margin-top: 10px">INICIAR JOGO</button>
            <small style="text-align: center; color: #666">Use o mesmo ID na URL para conectar: ?game=sala1</small>
          </div>
        </div>
      </div>

      <div id="gameSection">
        <div class="board">
          <div class="board-top">
            <div>
              <span class="current-player-chip">
                <span class="current-dot"></span>
                <span id="currentPlayerLabel">...</span>
              </span>
              <span id="turnTimerLabel" style="margin-left: 5px; font-size: 11px; color: #facc15"></span>
            </div>

            <div class="morto-area">
              <div id="mortoSlot0" class="morto-container" title="Morto Time 1">
                <div class="morto-card-back"></div>
                <div class="morto-card-back offset"></div>
                <span class="morto-label">Morto 1</span>
              </div>
              <div id="mortoSlot1" class="morto-container" title="Morto Time 2">
                <div class="morto-card-back"></div>
                <div class="morto-card-back offset"></div>
                <span class="morto-label">Morto 2</span>
              </div>
            </div>
          </div>

          <div id="opponentTop" class="opponent-hand opponent-hand-top"></div>
          <div id="opponentLeft" class="opponent-hand opponent-hand-left"></div>
          <div id="opponentRight" class="opponent-hand opponent-hand-right"></div>

          <div class="board-melds">
            <div class="grow">
              <div class="meld-title">
                <span>Time 1 Pts:</span>
                <strong id="scoreTeam1">0</strong>
              </div>
              <div id="meldsP1" class="meld-container"></div>
            </div>
            <div class="grow" style="border-left: 1px dashed rgba(255, 255, 255, 0.1); padding-left: 5px">
              <div class="meld-title">
                <span>Time 2 Pts:</span>
                <strong id="scoreTeam2">0</strong>
              </div>
              <div id="meldsP2" class="meld-container"></div>
            </div>
          </div>

          <div class="board-middle">
            <div class="pile-area" id="drawStockBtn">
              <div class="pile-card"><div class="pile-card-inner"></div></div>
              <div class="pile-info">
                Monte (
                <span id="stockCount">0</span>
                )
              </div>
            </div>

            <div class="pile-area" id="drawDiscardBtn">
              <div class="pile-card discard-pile">
                <div id="discardFace" class="discard-face">
                  <div id="discardFaceTop"></div>
                  <div id="discardFaceBottom"></div>
                </div>
              </div>
              <div class="pile-info">
                Lixo (
                <span id="discardCount">0</span>
                )
              </div>
              <span id="discardTop" style="display: none"></span>
            </div>
          </div>

          <div class="player-interface">
            <div id="message"></div>

            <div class="player-actions">
              <button id="meldBtn">‚¨áÔ∏è Baixar</button>
              <button id="discardBtn">üóëÔ∏è Descartar</button>
              <button id="takeDeadBtn">üíÄ Morto</button>
              <button id="endGameBtn" style="background: #333; font-size: 10px; padding: 8px">‚ùå</button>
            </div>

            <div style="position: absolute; right: 10px; top: 10px; font-size: 10px; color: #aaa">
              <span id="handCountLabel"></span>
            </div>

            <div id="handContainer" class="hand-container">
              <div class="cards-row"></div>
            </div>
          </div>
        </div>
      </div>
      <div id="scoreSection" style="display: none">
        <div class="section" style="width: 90%; max-width: 500px">
          <h2>Fim de Jogo</h2>
          <div id="scoreBoard"></div>
          <button id="closeScoreBtn" style="width: 100%; margin-top: 10px">Fechar</button>
        </div>
      </div>
    </div>

    <script type="module">
      import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js';
      import { getFirestore, doc, setDoc, updateDoc, onSnapshot, deleteDoc } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js';

      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          // SW opcional
        });
      }

      const firebaseConfig = {
        apiKey: 'AIzaSyBHvYOK7pWkikA9x5AjrVjuuSmopHisGik',
        authDomain: 'buraco-27cb3.firebaseapp.com',
        projectId: 'buraco-27cb3',
        storageBucket: 'buraco-27cb3.firebasestorage.app',
        messagingSenderId: '793904091112',
        appId: '1:793904091112:web:3e9f299f5603ee4b6a5e5d',
        measurementId: 'G-Q0RRR9714T',
      };

      const app = initializeApp(firebaseConfig);
      const db = getFirestore(app);

      const urlParams = new URLSearchParams(window.location.search);
      const gameId = urlParams.get('game') || 'teste';
      let myPlayerIndex = parseInt(urlParams.get('player') || '0', 10);

      const gameRef = doc(db, 'buracoGames', gameId);

      const SUITS = ['‚ô£', '‚ô¶', '‚ô•', '‚ô†'];
      const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
      const RANKS_SEQ = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
      const RANKS_SEQ_LOW = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

      const DEAD_CHUNK_SIZE = 11;

      let state = null;
      let selectedHandIndexes = new Set();
      let turnTimerId = null;
      let turnTimerRemaining = 0;
      let selectedMeldTarget = null;

      function updateTimerLabel() {
        const el = document.getElementById('turnTimerLabel');
        if (!el) return;
        if (!state || state.finished || state.currentPlayer !== myPlayerIndex) {
          el.textContent = '';
          return;
        }
        el.textContent = `${turnTimerRemaining}s`;
      }

      function stopTurnTimer() {
        if (turnTimerId !== null) {
          clearInterval(turnTimerId);
          turnTimerId = null;
        }
      }

      async function autoPlayTimeout() {
        if (!ensureMyTurn()) return;
        if (!state.hasDrawnThisTurn) {
          if (!state.stock.length) recycleDeadToStockIfPossible();
          if (state.stock.length) {
            const c = state.stock.pop();
            const me = currentPlayer();
            me.hand.push(c);
            sortHand(me.hand);
            state.hasDrawnThisTurn = true;
          } else if (state.discard.length && state.variant === 'aberto') {
            const c = state.discard.pop();
            const me = currentPlayer();
            me.hand.push(c);
            sortHand(me.hand);
            state.hasDrawnThisTurn = true;
          }
        }
        const me = currentPlayer();
        const hand = me.hand;
        if (!hand.length) {
          await commitState();
          return;
        }
        if (state.variant === 'fechado' && state.requiredDiscardCard) {
          showMessage('Tempo esgotado, obrigat√≥rio usar descarte (regra fechada).');
          return;
        }
        const idx = Math.floor(Math.random() * hand.length);
        const card = hand.splice(idx, 1)[0];
        state.discard.push(card);

        const teamId = me.teamId;
        const taken = state.deadChunksTaken?.[teamId] ?? 0;
        const max = state.deadChunksMax?.[teamId] ?? 1;

        if (hand.length === 0 && taken >= max) {
          await finishGame(teamId);
          return;
        }

        if (state.mode === '1x1_duploMorto') {
          if (state.currentPlayer === 1) {
            if (!state.j2ConsecutiveTurns || state.j2ConsecutiveTurns === 0) {
              state.j2ConsecutiveTurns = 1;
            } else {
              state.currentPlayer = 0;
              state.j2ConsecutiveTurns = 0;
            }
          } else {
            state.currentPlayer = 1;
            state.j2ConsecutiveTurns = 0;
          }
        } else {
          state.currentPlayer = (state.currentPlayer + 1) % state.players.length;
        }

        state.hasDrawnThisTurn = false;
        state.requiredDiscardCard = null;
        showMessage('Tempo esgotado: auto-play.');
        await commitState();
      }

      function classifyMeldForUi(meld) {
        if (!meld || meld.length < 7) return { kind: 'simple', base: 'Jogo', tag: null };
        const hasWild = hasRealWild(meld);
        const nonJoker = meld.filter((c) => !c.joker);
        if (!nonJoker.length) return { kind: 'simple', base: 'Jogo', tag: null };

        const orderLow = {};
        RANKS_SEQ_LOW.forEach((r, i) => (orderLow[r] = i));
        const orderHigh = {};
        RANKS_SEQ.forEach((r, i) => (orderHigh[r] = i));

        const sortedLow = nonJoker.slice().sort((a, b) => orderLow[a.rank] - orderLow[b.rank]);
        const ranksLow = sortedLow.map((c) => c.rank);
        const aceCount = ranksLow.filter((r) => r === 'A').length;
        const uniqueIdxsLow = [...new Set(ranksLow.map((r) => orderLow[r]))];
        let contiguousLow = true;
        for (let i = 1; i < uniqueIdxsLow.length; i++) if (uniqueIdxsLow[i] !== uniqueIdxsLow[i - 1] + 1) contiguousLow = false;

        const sortedHigh = nonJoker.slice().sort((a, b) => orderHigh[a.rank] - orderHigh[b.rank]);
        const ranksHigh = sortedHigh.map((c) => c.rank);
        const uniqueIdxsHigh = [...new Set(ranksHigh.map((r) => orderHigh[r]))];
        let contiguousHigh = true;
        for (let i = 1; i < uniqueIdxsHigh.length; i++) if (uniqueIdxsHigh[i] !== uniqueIdxsHigh[i - 1] + 1) contiguousHigh = false;

        const firstRankLow = ranksLow[0];
        const lastRankLow = ranksLow[ranksLow.length - 1];
        const firstRankHigh = ranksHigh[0];
        const lastRankHigh = ranksHigh[ranksHigh.length - 1];
        const hasKing = ranksLow.includes('K') || ranksHigh.includes('K');
        const contiguous = contiguousLow || contiguousHigh;

        if (hasWild) return { kind: 'suja', base: 'Canastra', tag: { cls: 'suja', text: 'Suja' } };
        if (!contiguous) return { kind: 'simple', base: 'Jogo', tag: null };

        let isReal = false;
        let isAsAs = false;
        if (aceCount >= 2 && firstRankLow === 'A' && lastRankHigh === 'A' && hasKing && contiguousLow && contiguousHigh && ranksLow.length >= 8) isAsAs = true;
        else if (aceCount === 1 && firstRankLow === 'A' && lastRankLow === 'K' && contiguousLow && ranksLow.length >= 7) isReal = true;

        if (isAsAs) return { kind: 'asas', base: 'C. √Ås-√Ås', tag: { cls: 'real', text: 'Real' } };
        if (isReal) return { kind: 'real', base: 'C. Real', tag: { cls: 'real', text: 'Real' } };

        return { kind: 'limpa', base: 'Canastra', tag: { cls: 'limpa', text: 'Limpa' } };
      }

      function startTurnTimerIfNeeded() {
        stopTurnTimer();
        if (!state || state.finished || state.currentPlayer !== myPlayerIndex) {
          updateTimerLabel();
          return;
        }
        turnTimerRemaining = 60;
        updateTimerLabel();
        turnTimerId = setInterval(() => {
          turnTimerRemaining--;
          if (turnTimerRemaining <= 0) {
            stopTurnTimer();
            autoPlayTimeout().catch(console.error);
          } else {
            updateTimerLabel();
          }
        }, 1000);
      }

      function createDeck() {
        const deck = [];
        for (let d = 0; d < 2; d++) {
          for (const s of SUITS) for (const r of RANKS) deck.push({ rank: r, suit: s, joker: false });
          deck.push({ rank: 'JOKER', suit: '‚òÖ', joker: true });
          deck.push({ rank: 'JOKER', suit: '‚òÖ', joker: true });
        }
        return deck;
      }

      function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }

      function recycleDeadToStockIfPossible() {
        if (!state || state.stock.length) return false;
        let collected = [];
        if (state.deadPiles && state.deadPiles.length) {
          state.deadPiles.forEach((pile, idx) => {
            if (pile && pile.length) {
              collected = collected.concat(pile);
              state.deadPiles[idx] = [];
              if (state.deadChunksTaken && state.deadChunksMax) state.deadChunksTaken[idx] = state.deadChunksMax[idx] ?? state.deadChunksTaken[idx];
            }
          });
        }
        if (!collected.length) return false;
        shuffle(collected);
        state.stock = collected;
        return true;
      }

      function cardLabel(card) {
        if (card.joker) return 'JOKER';
        return card.rank + card.suit;
      }

      function isWildcard(card, meld = null) {
        if (!card) return false;
        if (card.joker) return true;
        if (card.rank !== '2') return false;
        if (!meld || !Array.isArray(meld)) return true;
        const sameSuitRanks = meld.filter((c) => !c.joker && c.suit === card.suit).map((c) => c.rank);
        const hasAce = sameSuitRanks.includes('A');
        const hasThree = sameSuitRanks.includes('3');
        if (hasAce || hasThree) return false;
        return true;
      }

      function cardBasePoints(card) {
        if (card.joker) return 20;
        if (card.rank === 'A' || card.rank === '2') return 15;
        if (['3', '4', '5', '6', '7'].includes(card.rank)) return 5;
        return 10;
      }

      function hasRealWild(meld) {
        return meld.some((c) => isWildcard(c, meld));
      }

      function sortHand(hand) {
        const rankOrder = {};
        RANKS_SEQ.forEach((r, idx) => (rankOrder[r] = idx));
        hand.sort((a, b) => {
          if (a.joker && !b.joker) return 1;
          if (!a.joker && b.joker) return -1;
          if (a.suit === b.suit) return rankOrder[a.rank] - rankOrder[b.rank];
          return SUITS.indexOf(a.suit) - SUITS.indexOf(b.suit);
        });
      }

      async function startGame(mode, names, variant) {
        if (myPlayerIndex !== 0) {
          showMessage('S√≥ Jogador 1 inicia.');
          return;
        }
        const players = [];
        const teams = [];
        let playerConfigs = [];
        if (mode === '1x1' || mode === '1x1_duploMorto') {
          playerConfigs = [
            { name: names[0] || 'J1', team: 0 },
            { name: names[1] || 'J2', team: 1 },
          ];
        } else if (mode === '2x2') {
          playerConfigs = [
            { name: names[0] || 'J1', team: 0 },
            { name: names[1] || 'J2', team: 1 },
            { name: names[2] || 'J3', team: 0 },
            { name: names[3] || 'J4', team: 1 },
          ];
        } else if (mode === '1x2') {
          playerConfigs = [
            { name: names[0] || 'Solo', team: 0 },
            { name: names[1] || 'D1', team: 1 },
            { name: names[2] || 'D2', team: 1 },
          ];
        }
        playerConfigs.forEach((cfg, idx) => {
          players.push({ id: idx, name: cfg.name, teamId: cfg.team, hand: [] });
        });
        for (let t = 0; t < 2; t++) {
          const playerIndexes = players.filter((p) => p.teamId === t).map((p) => p.id);
          teams.push({ id: t, name: t === 0 ? 'Time 1' : 'Time 2', playerIndexes, melds: [] });
        }
        let stock = shuffle(createDeck());
        const discard = [];
        const deadPiles = [[], []];
        const HAND_SIZE = 11;
        for (let i = 0; i < HAND_SIZE; i++) for (let pIdx = 0; pIdx < players.length; pIdx++) players[pIdx].hand.push(stock.pop());
        for (let i = 0; i < DEAD_CHUNK_SIZE; i++) {
          deadPiles[0].push(stock.pop());
          deadPiles[1].push(stock.pop());
        }
        players.forEach((p) => sortHand(p.hand));
        discard.push(stock.pop());
        let deadChunksMax = [1, 1];
        if (mode === '1x1_duploMorto') deadChunksMax = [1, 2];
        const newState = {
          mode,
          variant,
          players,
          teams,
          currentPlayer: 0,
          stock,
          discard,
          deadPiles,
          deadChunksTaken: [0, 0],
          deadChunksMax,
          hasDrawnThisTurn: false,
          finished: false,
          winnerTeamId: null,
          j2ConsecutiveTurns: 0,
          requiredDiscardCard: null,
        };
        await setDoc(gameRef, { stateJson: JSON.stringify(newState), createdAt: Date.now() });
        showMessage('Partida iniciada!');
      }

      function currentPlayer() {
        return state.players[state.currentPlayer];
      }
      function currentTeam() {
        return state.teams[currentPlayer().teamId];
      }
      function ensureMyTurn() {
        if (!state || state.finished) {
          showMessage('Fim de jogo.');
          return false;
        }
        if (state.currentPlayer !== myPlayerIndex) {
          showMessage('Aguarde sua vez.');
          return false;
        }
        return true;
      }
      async function commitState() {
        await updateDoc(gameRef, { stateJson: JSON.stringify(state) });
      }

      async function drawFromStock() {
        if (!ensureMyTurn()) return;
        if (state.hasDrawnThisTurn) {
          showMessage('J√° comprou.');
          return;
        }
        if (!state.stock.length) {
          if (!recycleDeadToStockIfPossible() || !state.stock.length) {
            showMessage('Monte vazio.');
            return;
          } else showMessage('Morto virou monte.');
        }
        const c = state.stock.pop();
        currentPlayer().hand.push(c);
        sortHand(currentPlayer().hand);
        state.hasDrawnThisTurn = true;
        await commitState();
      }

      function canUseDiscardInClosed(discardTop, hand, team) {
        if (!discardTop) return false;
        const n = hand.length;
        const pool = hand.concat([discardTop]);
        const idxTopo = pool.length - 1;
        const totalMasks = 1 << pool.length;
        for (let mask = 0; mask < totalMasks; mask++) {
          if (!(mask & (1 << idxTopo))) continue;
          const subset = [];
          for (let i = 0; i < pool.length; i++) if (mask & (1 << i)) subset.push(pool[i]);
          if (subset.length >= 3 && isValidSequenceMeld(subset)) return true;
        }
        if (team && team.melds && team.melds.length) {
          for (const meld of team.melds) {
            const base = meld;
            const maxMask2 = 1 << n;
            for (let mask = 0; mask < maxMask2; mask++) {
              const subset = base.slice();
              subset.push(discardTop);
              for (let i = 0; i < n; i++) if (mask & (1 << i)) subset.push(hand[i]);
              if (isValidSequenceMeld(subset)) return true;
            }
          }
        }
        return false;
      }

      async function drawFromDiscard() {
        if (!ensureMyTurn()) return;
        if (state.hasDrawnThisTurn) {
          showMessage('J√° comprou.');
          return;
        }
        if (!state.discard.length) {
          showMessage('Lixo vazio.');
          return;
        }
        const top = state.discard[state.discard.length - 1];
        const me = currentPlayer();
        if (state.variant === 'fechado') {
          const canUse = canUseDiscardInClosed(top, me.hand, currentTeam());
          if (!canUse) {
            showMessage('Fechado: a carta deve servir p/ jogo.');
            return;
          }
        }
        const pile = state.discard.splice(0, state.discard.length);
        me.hand.push(...pile);
        sortHand(me.hand);
        state.hasDrawnThisTurn = true;
        if (state.variant === 'fechado') state.requiredDiscardCard = { rank: top.rank, suit: top.suit, joker: !!top.joker };
        else state.requiredDiscardCard = null;
        await commitState();
      }

      function isValidSequenceMeld(cards) {
        if (!cards || cards.length < 3) return false;
        const wildCards = cards.filter((c) => isWildcard(c, cards));
        if (wildCards.length > 1) return false;
        const nonWild = cards.filter((c) => !isWildcard(c, cards));
        if (!nonWild.length) return false;
        const suit = nonWild[0].suit;
        if (!nonWild.every((c) => c.suit === suit)) return false;
        const availableWilds = cards.length - nonWild.length;

        function neededWildsForOrder(order, aceMode) {
          const seqOrder = {};
          order.forEach((r, i) => (seqOrder[r] = i));
          const sorted = nonWild.slice().sort((a, b) => seqOrder[a.rank] - seqOrder[b.rank]);
          const acePosInOrder = seqOrder['A'];
          const aceIndex = sorted.findIndex((c) => c.rank === 'A');
          if (aceIndex !== -1) {
            if (aceMode === 'high' && aceIndex !== sorted.length - 1) return null;
            if (aceMode === 'low' && aceIndex !== 0) return null;
            if (aceMode === 'none') return null;
          }
          let needed = 0;
          for (let i = 1; i < sorted.length; i++) {
            const prev = seqOrder[sorted[i - 1].rank];
            const curr = seqOrder[sorted[i].rank];
            if (prev == null || curr == null) return null;
            const diff = curr - prev;
            if (diff <= 0) return null;
            if (diff > 1) needed += diff - 1;
          }
          return needed;
        }
        const needHigh = neededWildsForOrder(RANKS_SEQ, 'high');
        const needLow = neededWildsForOrder(RANKS_SEQ_LOW, 'low');
        return (needHigh !== null && needHigh <= availableWilds) || (needLow !== null && needLow <= availableWilds);
      }

      async function attemptExtendExistingMeld(cards, indexes) {
        const team = currentTeam();
        if (!team.melds || !team.melds.length) return false;
        const hand = currentPlayer().hand;
        let forcedIndex = null;
        if (selectedMeldTarget) {
          const [teamIdStr, meldIdxStr] = selectedMeldTarget.split(':');
          if (parseInt(teamIdStr) === team.id && team.melds[parseInt(meldIdxStr)]) forcedIndex = parseInt(meldIdxStr);
        }
        if (forcedIndex !== null) {
          const targetMeld = team.melds[forcedIndex];
          const combined = targetMeld.concat(cards);
          if (!isValidSequenceMeld(combined)) {
            showMessage('N√£o encaixa.');
            return false;
          }
          for (const idx of indexes) {
            targetMeld.push(hand[idx]);
            hand.splice(idx, 1);
          }
          normalizeMeldOrder(targetMeld);
          sortHand(hand);
          selectedHandIndexes.clear();
          selectedMeldTarget = null;
          await commitState();
          showMessage('Cartas adicionadas!');
          return true;
        }
        const candidateMeldIndexes = [];
        team.melds.forEach((meld, idx) => {
          if (isValidSequenceMeld(meld.concat(cards))) candidateMeldIndexes.push(idx);
        });
        if (!candidateMeldIndexes.length) return false;
        if (candidateMeldIndexes.length > 1) {
          showMessage('Encaixa em v√°rios. Selecione o jogo.');
          return false;
        }
        const teamMeld = team.melds[candidateMeldIndexes[0]];
        for (const idx of indexes) {
          teamMeld.push(hand[idx]);
          hand.splice(idx, 1);
        }
        normalizeMeldOrder(teamMeld);
        sortHand(hand);
        selectedHandIndexes.clear();
        selectedMeldTarget = null;
        await commitState();
        return true;
      }

      async function makeMeldFromSelection() {
        if (!ensureMyTurn()) return;
        if (!state.hasDrawnThisTurn) {
          showMessage('Compre primeiro.');
          return;
        }
        const hand = currentPlayer().hand;
        const indexes = Array.from(selectedHandIndexes).sort((a, b) => b - a);
        if (!indexes.length) {
          showMessage('Selecione cartas.');
          return;
        }
        const cards = indexes.map((i) => hand[i]);
        const extended = await attemptExtendExistingMeld(cards, indexes);
        if (extended) return;
        if (indexes.length < 3) {
          showMessage('Novo jogo: m√≠n 3 cartas.');
          return;
        }
        if (!isValidSequenceMeld(cards)) {
          showMessage('Sequ√™ncia inv√°lida.');
          return;
        }
        const meld = [];
        for (const idx of indexes) {
          meld.unshift(hand[idx]);
          hand.splice(idx, 1);
        }
        normalizeMeldOrder(meld);
        currentTeam().melds.push(meld);
        selectedHandIndexes.clear();
        await commitState();
      }

      async function takeDead() {
        if (!ensureMyTurn()) return;
        const p = currentPlayer();
        const teamId = p.teamId;
        const taken = state.deadChunksTaken?.[teamId] ?? 0;
        const max = state.deadChunksMax?.[teamId] ?? 1;
        if (taken >= max) {
          showMessage('Sem mortos p/ sua equipe.');
          return;
        }
        if (p.hand.length > 0) {
          showMessage('M√£o deve estar vazia.');
          return;
        }
        let deadIndex = teamId;
        if (state.mode === '1x1_duploMorto' && teamId === 1 && taken >= 1) {
          if (!state.deadPiles[deadIndex].length) deadIndex = 0;
        }
        const dead = state.deadPiles[deadIndex];
        if (!dead || !dead.length) {
          showMessage('Morto vazio.');
          return;
        }
        const chunkSize = Math.min(DEAD_CHUNK_SIZE, dead.length);
        p.hand = dead.splice(0, chunkSize);
        sortHand(p.hand);
        state.deadChunksTaken[teamId] = taken + 1;
        await commitState();
      }

      async function discardSelectedCard() {
        if (!ensureMyTurn()) return;
        if (!state.hasDrawnThisTurn) {
          showMessage('Compre primeiro.');
          return;
        }
        if (state.variant === 'fechado' && state.requiredDiscardCard) {
          const must = state.requiredDiscardCard;
          const stillInHand = currentPlayer().hand.some((c) => c.rank === must.rank && c.suit === must.suit && !!c.joker === !!must.joker);
          if (stillInHand) {
            showMessage('Use a carta do lixo antes.');
            return;
          }
        }
        const hand = currentPlayer().hand;
        const indexes = Array.from(selectedHandIndexes);
        if (indexes.length !== 1) {
          showMessage('Selecione 1 carta.');
          return;
        }
        const index = indexes[0];
        const card = hand.splice(index, 1)[0];
        state.discard.push(card);
        selectedHandIndexes.clear();
        const teamId = currentPlayer().teamId;
        const taken = state.deadChunksTaken?.[teamId] ?? 0;
        const max = state.deadChunksMax?.[teamId] ?? 1;
        if (hand.length === 0 && taken >= max) {
          await finishGame(teamId);
          return;
        }

        if (state.mode === '1x1_duploMorto') {
          if (state.currentPlayer === 1) {
            state.j2ConsecutiveTurns = !state.j2ConsecutiveTurns ? 1 : 0;
            if (state.j2ConsecutiveTurns === 0) state.currentPlayer = 0;
          } else {
            state.currentPlayer = 1;
            state.j2ConsecutiveTurns = 0;
          }
        } else {
          state.currentPlayer = (state.currentPlayer + 1) % state.players.length;
        }
        state.requiredDiscardCard = null;
        state.hasDrawnThisTurn = false;
        await commitState();
      }

      function computeTeamMeldScore(team) {
        let meldPoints = 0,
          sujaBonus = 0,
          limpaBonus = 0,
          realBonus = 0,
          asasBonus = 0;
        if (!team || !team.melds) return { total: 0 };
        team.melds.forEach((meld) => {
          meld.forEach((c) => (meldPoints += cardBasePoints(c)));
          if (meld.length >= 7) {
            const info = classifyMeldForUi(meld);
            if (info.kind === 'suja') sujaBonus += 100;
            if (info.kind === 'limpa') limpaBonus += 200;
            if (info.kind === 'real') realBonus += 500;
            if (info.kind === 'asas') asasBonus += 1000;
          }
        });
        return { meldPoints, sujaBonus, limpaBonus, realBonus, asasBonus, total: meldPoints + sujaBonus + limpaBonus + realBonus + asasBonus };
      }

      function normalizeMeldOrder(meld) {
        // (L√≥gica complexa de ordena√ß√£o mantida intacta)
        if (!meld || !meld.length) return;
        const nonWild = meld.filter((c) => !isWildcard(c, meld));
        const wild = meld.filter((c) => isWildcard(c, meld));
        if (!nonWild.length) {
          meld.splice(0, meld.length, ...wild);
          return;
        }
        const availableWilds = wild.length;
        function neededWildsForOrder(order, aceMode) {
          const seqOrder = {};
          order.forEach((r, i) => (seqOrder[r] = i));
          const sorted = nonWild.slice().sort((a, b) => seqOrder[a.rank] - seqOrder[b.rank]);
          const aceIndex = sorted.findIndex((c) => c.rank === 'A');
          if (aceIndex !== -1) {
            if (aceMode === 'high' && aceIndex !== sorted.length - 1) return null;
            if (aceMode === 'low' && aceIndex !== 0) return null;
            if (aceMode === 'none') return null;
          }
          let needed = 0;
          for (let i = 1; i < sorted.length; i++) {
            const diff = seqOrder[sorted[i].rank] - seqOrder[sorted[i - 1].rank];
            if (diff <= 0) return null;
            if (diff > 1) needed += diff - 1;
          }
          return needed;
        }
        const needHigh = neededWildsForOrder(RANKS_SEQ, 'high');
        const needLow = neededWildsForOrder(RANKS_SEQ_LOW, 'low');
        const okHigh = needHigh !== null && needHigh <= availableWilds;
        const okLow = needLow !== null && needLow <= availableWilds;

        let order, aceMode;
        if (okHigh && okLow) {
          if (needHigh <= needLow) {
            order = RANKS_SEQ;
            aceMode = 'high';
          } else {
            order = RANKS_SEQ_LOW;
            aceMode = 'low';
          }
        } else if (okHigh) {
          order = RANKS_SEQ;
          aceMode = 'high';
        } else if (okLow) {
          order = RANKS_SEQ_LOW;
          aceMode = 'low';
        } else return;

        const seqOrder = {};
        order.forEach((r, i) => (seqOrder[r] = i));
        const sortedNonWild = nonWild.slice().sort((a, b) => seqOrder[a.rank] - seqOrder[b.rank]);
        const middle = [];
        const wildQueue = [...wild];
        for (let i = 0; i < sortedNonWild.length; i++) {
          middle.push(sortedNonWild[i]);
          if (i < sortedNonWild.length - 1) {
            let gap = seqOrder[sortedNonWild[i + 1].rank] - seqOrder[sortedNonWild[i].rank] - 1;
            while (gap > 0 && wildQueue.length) {
              middle.push(wildQueue.shift());
              gap--;
            }
          }
        }
        const prefix = [];
        const suffix = [];
        if (aceMode === 'high') {
          while (wildQueue.length) prefix.push(wildQueue.shift());
        } else {
          while (wildQueue.length) suffix.push(wildQueue.shift());
        }
        meld.splice(0, meld.length, ...prefix, ...middle, ...suffix);
      }

      function computeScores() {
        const results = [];
        state.teams.forEach((team) => {
          const players = state.players.filter((p) => p.teamId === team.id);
          let handPenalty = 0;
          players.forEach((p) => p.hand.forEach((c) => (handPenalty += cardBasePoints(c))));
          const meldInfo = computeTeamMeldScore(team);
          results.push({ team, players, score: meldInfo.total - handPenalty, handPenalty, ...meldInfo });
        });
        return results;
      }

      async function finishGame(winnerTeamId) {
        if (!state) return;
        state.finished = true;
        state.winnerTeamId = winnerTeamId ?? null;
        await commitState();
      }

      // RENDER
      function renderAll() {
        if (!state) return;
        document.getElementById('currentPlayerLabel').textContent = currentPlayer().name;
        document.getElementById('stockCount').textContent = state.stock.length;

        // Descarte
        const discardTop = state.discard[state.discard.length - 1];
        document.getElementById('discardCount').textContent = state.discard.length;
        const discardFace = document.getElementById('discardFace');
        const fTop = document.getElementById('discardFaceTop');
        const fBot = document.getElementById('discardFaceBottom');
        if (!discardTop) discardFace.style.display = 'none';
        else {
          discardFace.style.display = 'flex';
          if (discardTop.joker) {
            fTop.textContent = '‚òÖ';
            fBot.textContent = '‚òÖ';
            discardFace.style.color = '#b45309';
          } else {
            fTop.innerHTML = discardTop.rank + '<br>' + discardTop.suit;
            fBot.textContent = discardTop.suit;
            discardFace.style.color = discardTop.suit === '‚ô•' || discardTop.suit === '‚ô¶' ? '#b91c1c' : '#000';
          }
        }

        // Mortos
        const s0 = document.getElementById('mortoSlot0');
        const s1 = document.getElementById('mortoSlot1');
        if (state.deadPiles.length >= 2) {
          s0.classList.toggle('used', state.deadPiles[0].length === 0);
          s1.classList.toggle('used', state.deadPiles[1].length === 0);
        }

        // M√£os Oponentes
        renderOpponentHands();

        // Minha M√£o
        renderHand();

        // Jogos
        renderMelds();

        // Bot√µes
        const myTurn = !state.finished && state.currentPlayer === myPlayerIndex;
        document.getElementById('drawStockBtn').style.pointerEvents = myTurn && !state.hasDrawnThisTurn ? 'auto' : 'none';
        document.getElementById('drawStockBtn').style.opacity = myTurn && !state.hasDrawnThisTurn ? '1' : '0.5';

        document.getElementById('drawDiscardBtn').style.pointerEvents = myTurn && !state.hasDrawnThisTurn && state.discard.length ? 'auto' : 'none';
        document.getElementById('drawDiscardBtn').style.opacity = myTurn && !state.hasDrawnThisTurn && state.discard.length ? '1' : '0.5';

        document.getElementById('meldBtn').disabled = !myTurn || !state.hasDrawnThisTurn;
        document.getElementById('discardBtn').disabled = !myTurn || !state.hasDrawnThisTurn;

        const teamId = currentPlayer().teamId;
        const taken = state.deadChunksTaken?.[teamId] ?? 0;
        const max = state.deadChunksMax?.[teamId] ?? 1;
        document.getElementById('takeDeadBtn').disabled = !myTurn || taken >= max;
        document.getElementById('endGameBtn').disabled = false;

        if (state.finished) renderScores(computeScores(), state.winnerTeamId);
      }

      function renderHand() {
        const container = document.querySelector('#handContainer .cards-row');
        container.innerHTML = '';
        const me = state.players[myPlayerIndex];
        document.getElementById('handCountLabel').textContent = me.hand.length;
        me.hand.forEach((card, idx) => {
          const div = document.createElement('div');
          div.className = 'carta ' + (card.joker ? 'joker-card' : card.suit === '‚ô•' || card.suit === '‚ô¶' ? 'hearts' : 'spades');
          div.innerHTML = card.joker ? `<div class="carta-canto">JOKER</div><div class="carta-icone">‚òÖ</div>` : `<div class="carta-canto">${card.rank}<br>${card.suit}</div><div class="carta-icone">${card.suit}</div>`;
          if (selectedHandIndexes.has(idx)) div.classList.add('selected');
          div.onclick = () => {
            if (state.currentPlayer !== myPlayerIndex) return;
            if (selectedHandIndexes.has(idx)) selectedHandIndexes.delete(idx);
            else selectedHandIndexes.add(idx);
            renderHand();
          };
          container.appendChild(div);
        });
      }

      // ==========================
      // MODO TESTE / DEBUG 1
      // ==========================
      window.debugScoreExample = function () {
        // sempre testar como Jogador 1
        myPlayerIndex = 0;

        const C = (rank, suit, joker = false) => ({ rank, suit, joker });

        // monta um state COMPLETO s√≥ em mem√≥ria, sem Firebase
        state = {
          mode: '1x1',
          variant: 'fechado',
          players: [
            { id: 0, name: 'Jogador 1', teamId: 0, hand: [] },
            { id: 1, name: 'Jogador 2', teamId: 1, hand: [] },
          ],
          teams: [
            { id: 0, name: 'Time 1', playerIndexes: [0], melds: [] },
            { id: 1, name: 'Time 2', playerIndexes: [1], melds: [] },
          ],
          currentPlayer: 0,
          stock: [],
          discard: [],
          deadPiles: [[], []],
          deadChunksTaken: [1, 1],
          deadChunksMax: [1, 1],
          hasDrawnThisTurn: true,
          finished: true, // j√° marca como fim de jogo
          winnerTeamId: 0, // vit√≥ria da equipe 1
          j2ConsecutiveTurns: 0,
          requiredDiscardCard: null,
        };

        const t1 = state.teams[0].melds;
        const t2 = state.teams[1].melds;

        // ---------- TIME 1 ----------

        // 1) Canastra REAL (2 ... A do mesmo naipe, sem coringa)
        t1.push([C('A', '‚ô£'), C('2', '‚ô£'), C('3', '‚ô£'), C('4', '‚ô£'), C('5', '‚ô£'), C('6', '‚ô£'), C('7', '‚ô£'), C('8', '‚ô£'), C('9', '‚ô£'), C('10', '‚ô£'), C('J', '‚ô£'), C('Q', '‚ô£'), C('K', '‚ô£')]);

        // 2) Canastra √ÅS A √ÅS (come√ßa e termina com √Ås)
        t1.push([C('A', '‚ô¶'), C('2', '‚ô¶'), C('3', '‚ô¶'), C('4', '‚ô¶'), C('5', '‚ô¶'), C('6', '‚ô¶'), C('7', '‚ô¶'), C('8', '‚ô¶'), C('9', '‚ô¶'), C('10', '‚ô¶'), C('J', '‚ô¶'), C('Q', '‚ô¶'), C('K', '‚ô¶'), C('A', '‚ô¶')]);

        // 3) Canastra LIMPA (sem coringa, sem √Ås no topo)
        t1.push([C('4', '‚ô•'), C('5', '‚ô•'), C('6', '‚ô•'), C('7', '‚ô•'), C('8', '‚ô•'), C('9', '‚ô•'), C('10', '‚ô•')]);

        // ---------- TIME 2 ----------

        // 4) Canastra SUJA (com coringa no meio)
        t2.push([C('5', '‚ô†'), C('6', '‚ô†'), C('7', '‚ô†'), C('JOKER', '‚òÖ', true), C('9', '‚ô†'), C('10', '‚ô†'), C('J', '‚ô†')]);

        // ningu√©m com carta na m√£o
        state.players[0].hand = [];
        state.players[1].hand = [];

        // limpa sele√ß√µes
        selectedHandIndexes.clear();
        selectedMeldTarget = null;

        // renderiza tudo e j√° for√ßa o placar
        renderAll();
        const scores = computeScores();
        renderScores(scores, state.winnerTeamId);

        showMessage('DEBUG: exemplo com canastra real, √Ås a √Ås, limpa e suja.');
      };

      // =====================================================
      // MODO TESTE 2: playground para sequ√™ncias e coringas
      // =====================================================
      window.debugSequenciasCoringas = function () {
        // garante que voc√™ √© o Jogador 1
        myPlayerIndex = 0;

        const C = (rank, suit, joker = false) => ({ rank, suit, joker });

        // state completo, mas jogo N√ÉO terminado
        state = {
          mode: '1x1',
          variant: 'fechado',
          players: [
            { id: 0, name: 'Jogador 1', teamId: 0, hand: [] },
            { id: 1, name: 'Jogador 2', teamId: 1, hand: [] },
          ],
          teams: [
            { id: 0, name: 'Time 1', playerIndexes: [0], melds: [] },
            { id: 1, name: 'Time 2', playerIndexes: [1], melds: [] },
          ],
          currentPlayer: 0,
          stock: [], // pode deixar vazio, foco √© mexer nos jogos
          discard: [], // se quiser testar compra do descarte, p√µe carta aqui
          deadPiles: [[], []],
          deadChunksTaken: [0, 0],
          deadChunksMax: [1, 1],
          hasDrawnThisTurn: true, // j√° ‚Äúcomprou‚Äù, pode s√≥ baixar / mexer jogo
          finished: false, // N√ÉO terminou
          winnerTeamId: null,
          j2ConsecutiveTurns: 0,
          requiredDiscardCard: null,
        };

        const t1 = state.teams[0].melds;
        const t2 = state.teams[1].melds;

        // ---------------- TIME 1 (seus jogos) ----------------

        // 1) A‚ô£ 2‚ô£ 3‚ô£ 4‚ô£ 5‚ô£ 6‚ô£ 7‚ô£  -> 2 N√ÉO √© coringa aqui (A-2-3)
        t1.push([C('A', '‚ô£'), C('2', '‚ô£'), C('3', '‚ô£'), C('4', '‚ô£'), C('5', '‚ô£'), C('6', '‚ô£'), C('7', '‚ô£')]);

        // 2) A‚ô• JOKER 3‚ô• 4‚ô• 5‚ô• -> buraco A‚Äì3 preenchido por coringa (suja)
        t1.push([C('A', '‚ô•'), C('JOKER', '‚òÖ', true), C('3', '‚ô•'), C('4', '‚ô•'), C('5', '‚ô•')]);

        // 3) 8‚ô¶ 9‚ô¶ JOKER J‚ô¶ Q‚ô¶ -> coringa no meio de sequ√™ncia normal
        t1.push([C('8', '‚ô¶'), C('9', '‚ô¶'), C('JOKER', '‚òÖ', true), C('J', '‚ô¶'), C('Q', '‚ô¶')]);

        // 4) Q‚ô† K‚ô† A‚ô† -> sequ√™ncia com √Ås alto
        t1.push([C('Q', '‚ô†'), C('K', '‚ô†'), C('A', '‚ô†')]);

        // ---------------- TIME 2 (refer√™ncia) ----------------

        // 5) 4‚ô† 5‚ô† 6‚ô† 7‚ô† 8‚ô† 9‚ô† 10‚ô† -> canastra limpa simples pra comparar
        t2.push([C('4', '‚ô†'), C('5', '‚ô†'), C('6', '‚ô†'), C('7', '‚ô†'), C('8', '‚ô†'), C('9', '‚ô†'), C('10', '‚ô†')]);

        // 6) A‚ô¶ 2‚ô¶ 3‚ô¶ 4‚ô¶ 5‚ô¶ 6‚ô¶ 7‚ô¶ 8‚ô¶ 9‚ô¶ 10‚ô¶
        t2.push([C('A', '‚ô¶'), C('2', '‚ô¶'), C('3', '‚ô¶'), C('4', '‚ô¶'), C('5', '‚ô¶'), C('6', '‚ô¶'), C('7', '‚ô¶'), C('8', '‚ô¶'), C('9', '‚ô¶'), C('10', '‚ô¶')]);

        // ---------------- CARTAS NA M√ÉO ----------------

        // Sua m√£o: v√°rios 2 e coringas pra voc√™ brincar de mover
        state.players[0].hand = [C('2', '‚ô•'), C('2', '‚ô†'), C('2', '‚ô¶'), C('JOKER', '‚òÖ', true), C('5', '‚ô£'), C('K', '‚ô¶'), C('A', '‚ô£')];

        // m√£o do jogador 2 s√≥ pra n√£o ficar vazia
        state.players[1].hand = [C('7', '‚ô†'), C('8', '‚ô†'), C('9', '‚ô†')];

        // limpa sele√ß√µes
        selectedHandIndexes.clear();
        selectedMeldTarget = null;

        renderAll();
        showMessage('DEBUG: playground de sequ√™ncias e coringas carregado.');
      };

      function renderOpponentHands() {
        const top = document.getElementById('opponentTop');
        top.innerHTML = '';
        const left = document.getElementById('opponentLeft');
        left.innerHTML = '';
        const right = document.getElementById('opponentRight');
        right.innerHTML = '';

        const total = state.players.length;
        const seats = { top: null, left: null, right: null };
        const others = [];
        for (let i = 1; i < total; i++) others.push((myPlayerIndex + i) % total);

        if (total === 2) seats.top = others[0];
        else if (total === 3) {
          seats.right = others[0];
          seats.left = others[1];
        } else {
          seats.right = others[0];
          seats.top = others[1];
          seats.left = others[2];
        }

        [
          { idx: seats.top, el: top },
          { idx: seats.left, el: left },
          { idx: seats.right, el: right },
        ].forEach((obj) => {
          if (obj.idx === null) return;
          const p = state.players[obj.idx];
          const label = document.createElement('div');
          label.className = 'opponent-label';
          label.textContent = `${p.name} (${p.hand.length})`;
          obj.el.appendChild(label);

          const cardsDiv = document.createElement('div');
          cardsDiv.className = 'opponent-cards';
          const count = Math.min(p.hand.length, 12);
          for (let i = 0; i < count; i++) {
            const c = document.createElement('div');
            c.className = 'opponent-card-back';
            cardsDiv.appendChild(c);
          }
          obj.el.appendChild(cardsDiv);
        });
      }

      function renderMelds() {
        const m1 = document.getElementById('meldsP1');
        m1.innerHTML = '';
        const m2 = document.getElementById('meldsP2');
        m2.innerHTML = '';
        let s1 = 0,
          s2 = 0;
        state.teams.forEach((t, i) => {
          const info = computeTeamMeldScore(t);
          if (i === 0) s1 = info.total;
          else s2 = info.total;
          const target = i === 0 ? m1 : m2;
          t.melds.forEach((meld, midx) => {
            const div = document.createElement('div');
            div.className = 'meld-line';
            const key = t.id + ':' + midx;
            if (selectedMeldTarget === key) div.classList.add('selected-meld');

            const row = document.createElement('div');
            row.className = 'meld-line-cards';
            const mInfo = classifyMeldForUi(meld);

            meld.forEach((c, cidx) => {
              if (mInfo.kind !== 'simple' && cidx === meld.length - 1) return;
              const minic = document.createElement('div');
              minic.className = 'carta mini ' + (c.joker ? 'joker-card' : c.suit === '‚ô•' || c.suit === '‚ô¶' ? 'hearts' : 'spades');
              minic.innerHTML = c.joker ? `<div class="carta-canto">‚òÖ</div>` : `<div class="carta-canto">${c.rank}${c.suit}</div>`;
              row.appendChild(minic);
            });

            if (mInfo.kind !== 'simple') {
              const last = meld[meld.length - 1];
              const closed = document.createElement('div');
              closed.className = 'carta mini canastra-fechada ' + (last.joker ? 'joker-card' : last.suit === '‚ô•' || last.suit === '‚ô¶' ? 'hearts' : 'spades');
              closed.innerHTML = last.joker ? `<div class="carta-canto">‚òÖ</div>` : `<div class="carta-canto">${last.rank}${last.suit}</div>`;
              row.appendChild(closed);
            }

            const meta = document.createElement('div');
            meta.className = 'meld-meta';
            meta.innerHTML = mInfo.base + (mInfo.tag ? ` <span class="meld-tag ${mInfo.tag.cls}">${mInfo.tag.text}</span>` : '');

            div.appendChild(row);
            div.appendChild(meta);
            div.onclick = () => {
              selectedMeldTarget = selectedMeldTarget === key ? null : key;
              showMessage(selectedMeldTarget ? 'Jogo selecionado.' : 'Sele√ß√£o limpa.');
              renderMelds();
            };
            target.appendChild(div);
          });
        });
        document.getElementById('scoreTeam1').textContent = s1;
        document.getElementById('scoreTeam2').textContent = s2;
      }

      function renderScores(scores, winner) {
        document.getElementById('scoreSection').style.display = 'flex';
        const board = document.getElementById('scoreBoard');
        board.innerHTML = '';
        scores.sort((a, b) => b.score - a.score);
        scores.forEach((s) => {
          board.innerHTML += `<div style="margin-bottom:8px; border-bottom:1px solid #333; padding-bottom:4px;">
              <strong style="color:${s.team.id === winner ? '#facc15' : '#fff'}">${s.team.name}</strong>: ${s.score} pts
              <div style="font-size:10px; color:#aaa;">M√£o: -${s.handPenalty} | Jogos: +${s.meldPoints} | B√¥nus: +${s.sujaBonus + s.limpaBonus + s.realBonus + s.asasBonus}</div>
            </div>`;
        });
      }

      function showMessage(msg) {
        document.getElementById('message').textContent = msg;
      }

      onSnapshot(gameRef, (snap) => {
        if (!snap.exists()) {
          state = null;
          selectedHandIndexes.clear();
          document.getElementById('configSection').style.display = 'block';
          document.getElementById('gameSection').style.display = 'none';
        } else {
          state = JSON.parse(snap.data().stateJson);
          selectedHandIndexes.clear();
          document.getElementById('configSection').style.display = 'none';
          document.getElementById('gameSection').style.display = 'flex'; // FLEX para o layout funcionar
          renderAll();
          startTurnTimerIfNeeded();
        }
      });

      document.getElementById('startBtn').onclick = () => {
        startGame(
          document.getElementById('modeSelect').value,
          [document.getElementById('p1Name').value, document.getElementById('p2Name').value, document.getElementById('p3Name').value, document.getElementById('p4Name').value],
          document.getElementById('variantSelect').value
        );
      };

      document.getElementById('localPlayerSelect').onchange = (e) => {
        myPlayerIndex = parseInt(e.target.value);
        if (state) renderAll();
      };
      document.getElementById('drawStockBtn').onclick = drawFromStock;
      document.getElementById('drawDiscardBtn').onclick = drawFromDiscard;
      document.getElementById('meldBtn').onclick = makeMeldFromSelection;
      document.getElementById('discardBtn').onclick = discardSelectedCard;
      document.getElementById('takeDeadBtn').onclick = takeDead;
      document.getElementById('endGameBtn').onclick = () => deleteDoc(gameRef);
      document.getElementById('closeScoreBtn').onclick = () => (document.getElementById('scoreSection').style.display = 'none');
    </script>
  </body>
</html>
