<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <title>Buraco ‚Äì Firebase</title>
    <link rel="manifest" href="manifest.webmanifest" />
    <meta name="theme-color" content="#020617" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="icon-32.png" />
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png" />
    <link rel="apple-touch-icon" sizes="192x192" href="icon-192.png" />

    <style>
      :root {
        --bg-main: #020617;
        --bg-panel-soft: rgba(15, 23, 42, 0.92);
        --accent: #22c55e;
        --accent-strong: #16a34a;
        --text-main: #e5e7eb;
        --text-muted: #9ca3af;
      }

      * {
        box-sizing: border-box;
        user-select: none;
        -webkit-tap-highlight-color: transparent; /* Remove piscar azul no toque */
      }

      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%; /* Fallback */
        height: 100dvh; /* Altura din√¢mica real do mobile */
        overflow: hidden; /* Trava scroll da p√°gina inteira */
        background: #020617;
        font-family: system-ui, -apple-system, sans-serif;
      }

      .app {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
      }

      /* TELA DE CONFIG (Scroll√°vel se necess√°rio) */
      #configSection {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        background: radial-gradient(circle at center, #064e3b 0%, #020617 100%);
        display: flex;
        flex-direction: column;
        justify-content: center;
      }

      /* ESTILOS DE CONFIGURA√á√ÉO */
      .section {
        background: rgba(15, 23, 42, 0.95);
        border-radius: 12px;
        padding: 20px;
        border: 1px solid #1f2937;
        max-width: 400px;
        margin: 0 auto;
        width: 100%;
      }
      .section h2 {
        margin-top: 0;
        color: #fff;
      }
      input,
      select {
        width: 100%;
        padding: 10px;
        margin-bottom: 10px;
        border-radius: 8px;
        border: 1px solid #4b5563;
        background: rgba(0, 0, 0, 0.3);
        color: white;
      }
      button {
        width: 100%;
        padding: 12px;
        border-radius: 99px;
        border: none;
        font-weight: bold;
        cursor: pointer;
        background: var(--accent-strong);
        color: white;
        margin-top: 5px;
      }

      /* ================= JOGO ================= */
      #gameSection {
        flex: 1;
        display: none; /* JS ativa display:flex */
        flex-direction: column;
        height: 100%;
        width: 100%;
        overflow: hidden;
        background: radial-gradient(circle at center, #15803d 0%, #14532d 100%);
      }

      .board {
        flex: 1;
        display: flex;
        flex-direction: column;
        position: relative;
        overflow: hidden; /* Garante que nada saia da mesa */
        padding-bottom: 0;
      }

      .board-center {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: center; /* desktop: pontos + monte/lixo bem no meio */
      }

      /* -- TOPO -- */
      .board-top {
        padding: 10px;
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        height: 50px; /* Altura fixa para n√£o variar */
        z-index: 20;
      }
      .current-player-chip {
        background: rgba(0, 0, 0, 0.5);
        padding: 4px 10px;
        border-radius: 20px;
        color: #fff;
        font-size: 12px;
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .current-dot {
        width: 8px;
        height: 8px;
        background: #4ade80;
        border-radius: 50%;
      }

      /* Mortos */
      .morto-area {
        display: flex;
        gap: 8px;
      }
      .morto-container {
        position: relative;
        width: 30px;
        height: 44px;
        opacity: 1;
      }

      .morto-label {
        position: absolute;
        bottom: -12px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 9px;
        color: #e5e7eb;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
      }

      .morto-container.used {
        opacity: 0;
      }
      .morto-card-back {
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 4px;
        background: #991b1b;
        border: 1px solid #fff;
      }
      .morto-card-back.offset {
        transform: translate(3px, -3px);
      }

      /* -- OPONENTES -- */
      .opponent-hand {
        position: absolute;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
        pointer-events: none;
        font-size: 10px;
        color: #e5e7eb;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
      }

      /* TOPO ‚Äì leque horizontal */
      .opponent-hand-top {
        top: 26px;
        left: 50%;
        transform: translateX(-50%);
      }

      /* LATERAIS ‚Äì ficam no meio da mesa */
      .opponent-hand-left,
      .opponent-hand-right {
        top: 50%;
        transform: translateY(-50%);
      }

      .opponent-hand-left {
        left: 10px;
        align-items: center;
      }

      .opponent-hand-right {
        right: 10px;
        align-items: center;
      }

      /* Nome + qtd de cartas */
      .opponent-label {
        font-size: 11px;
        opacity: 0.85;
        background: rgba(15, 23, 42, 0.9);
        padding: 2px 6px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.5);
      }

      .opponent-cards {
        display: flex;
        gap: 3px;
        min-width: 30px;
        min-height: 44px;
      }

      /* Verso das cartas dos oponentes */
      .opponent-card-back {
        width: 30px;
        height: 44px;
        border-radius: 6px;
        background: #7f1d1d;
        border: 1px solid #3d0a0a;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.7);
      }

      /* TOPO ‚Äì sobreposi√ß√£o leve, tipo leque */
      .opponent-hand-top .opponent-card-back {
        margin-left: -14px;
      }
      .opponent-hand-top .opponent-card-back:first-child {
        margin-left: 0;
      }

      /* LATERAIS ‚Äì coluna, levemente ‚Äújuntas‚Äù */
      .opponent-hand-left .opponent-cards,
      .opponent-hand-right .opponent-cards {
        flex-direction: column;
        align-items: center;
        min-width: 44px;
        min-height: 30px;
      }

      .opponent-hand-left .opponent-card-back,
      .opponent-hand-right .opponent-card-back {
        margin-top: -12px;
      }

      .opponent-hand-left .opponent-card-back:first-child,
      .opponent-hand-right .opponent-card-back:first-child {
        margin-top: 0;
      }

      /* Rota√ß√£o das laterais */
      .opponent-hand-left .opponent-card-back {
        transform: rotate(90deg);
        transform-origin: center center;
      }
      .opponent-hand-right .opponent-card-back {
        transform: rotate(-90deg);
        transform-origin: center center;
      }

      /* Laterais */
      .opponent-hand-left {
        top: 45%;
        left: 5px;
        transform: translateY(-50%);
      }
      .opponent-hand-left .opponent-card-back {
        transform: rotate(90deg);
        margin-bottom: -15px;
      }

      .opponent-hand-right {
        top: 45%;
        right: 5px;
        transform: translateY(-50%);
      }
      .opponent-hand-right .opponent-card-back {
        transform: rotate(-90deg);
        margin-bottom: -15px;
      }

      /* -- JOGOS BAIXADOS (√ÅREA DE MELDS) -- */
      .board-melds {
        flex: 0 0 auto;
        min-height: 60px;
        max-width: 760px;
        margin: 70px auto 4px;
        padding: 6px 10px;
        display: flex;
        gap: 20px;
        background: rgba(0, 0, 0, 0.15);
        border-radius: 8px;
        overflow: visible;
      }

      .board-melds .grow {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        background: rgba(15, 23, 42, 0.85);
        border-radius: 10px;
        padding: 6px 10px;
      }

      .board-melds .grow + .grow {
        padding-left: 16px !important;
        border-left: 1px dashed rgba(148, 163, 184, 0.5) !important;
      }

      .meld-title {
        display: flex;
        justify-content: space-between;
        font-size: 11px;
        color: #cbd5e1;
        margin-bottom: 4px;
      }

      .meld-container {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        align-content: flex-start;
        width: 100%;
        justify-content: flex-start;
        min-height: 52px;
      }

      .board-melds .grow {
        overflow: hidden;
      }

      .meld-line {
        max-width: 100%;
      }

      .meld-line {
        background: rgba(0, 0, 0, 0.45);
        border-radius: 6px;
        padding: 4px 6px 6px;
        display: flex;
        flex-direction: column;
        align-items: center;
        cursor: pointer;
        border: 1px solid transparent;
        flex: 0 1 auto;
        min-width: 140px;
      }

      .meld-line.selected-meld {
        border-color: #facc15;
        background: rgba(250, 204, 21, 0.2);
      }

      .meld-line-cards {
        display: flex;
        align-items: center;
        height: 42px;
      }

      .meld-meta {
        font-size: 10px;
        color: #e5e7eb;
        margin-top: 4px;
        text-align: center;
      }

      /* -- MEIO DA MESA (MONTE E LIXO) -- */
      .board-middle {
        display: flex;
        justify-content: center;
        gap: 30px;
        align-items: center;
        padding: 10px 0;
        flex-shrink: 0;
        z-index: 5;
      }

      .pile-area {
        display: flex;
        flex-direction: column;
        align-items: center;
        position: relative;
        cursor: pointer;
      }

      /* =========================
     MONTE (FIX): n√£o fica vermelho fixo
     ========================= */
      .pile-card {
        width: 55px;
        height: 80px;
        border-radius: 6px;
        background: transparent;
        border: 0;
        box-shadow: none;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: visible;
      }

      /* S√≥ o MONTE (n√£o o lixo): stack 50/50 em CSS */
      #drawStockBtn .pile-card::before,
      #drawStockBtn .pile-card::after {
        content: '';
        position: absolute;
        inset: 0;
        border-radius: 6px;
        border: 2px solid #fff;
        box-sizing: border-box;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
      }

      /* azul atr√°s */
      #drawStockBtn .pile-card::before {
        transform: translate(4px, -3px);
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 42%), radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0) 55%),
          repeating-linear-gradient(45deg, rgba(192, 192, 192, 0.22) 0 6px, rgba(0, 0, 0, 0) 6px 14px), repeating-linear-gradient(-45deg, rgba(0, 0, 0, 0.22) 0 7px, rgba(0, 0, 0, 0) 7px 16px), linear-gradient(135deg, #05071a, #1d4ed8);
      }

      /* vermelho na frente */
      #drawStockBtn .pile-card::after {
        transform: translate(0px, 0px);
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 42%), radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0) 55%),
          repeating-linear-gradient(45deg, rgba(255, 215, 0, 0.22) 0 6px, rgba(0, 0, 0, 0) 6px 14px), repeating-linear-gradient(-45deg, rgba(0, 0, 0, 0.22) 0 7px, rgba(0, 0, 0, 0) 7px 16px), linear-gradient(135deg, #140007, #b91c1c);
      }

      .pile-card.discard-pile {
        background: transparent;
        border: 2px dashed rgba(255, 255, 255, 0.4);
        box-shadow: none;
      }

      .discard-face {
        width: 100%;
        height: 100%;
        background: #f3f4f6;
        border-radius: 4px;
        color: #000;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        padding: 2px;
        font-weight: bold;
        font-size: 12px;
      }

      .pile-info {
        font-size: 10px;
        color: #fff;
        background: rgba(0, 0, 0, 0.7);
        padding: 2px 6px;
        border-radius: 10px;
        margin-top: -8px;
        z-index: 10;
      }

      /* -- √ÅREA DO JOGADOR (RODAP√â) -- */
      .player-interface {
        background: linear-gradient(to top, rgba(2, 6, 23, 0.95) 0%, rgba(2, 6, 23, 0.8) 60%, transparent 100%);
        padding: 5px 10px 10px 10px;
        display: flex;
        flex-direction: column;
        gap: 5px;
        z-index: 50;
        width: 100%;
        flex-shrink: 0;
      }

      #message {
        text-align: center;
        font-size: 11px;
        color: #facc15;
        font-weight: bold;
        height: 15px;
        text-shadow: 0 1px 2px black;
      }

      .player-actions {
        display: flex;
        justify-content: center;
        gap: 8px;
      }

      .player-actions button {
        width: auto;
        padding: 8px 12px;
        font-size: 11px;
        margin: 0;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      #meldBtn {
        background: #059669;
      }

      #discardBtn {
        background: #be123c;
      }

      #takeDeadBtn {
        background: #4f46e5;
      }

      #endGameBtn {
        background: #333;
        padding: 8px;
      }

      /* M√ÉO DO JOGADOR - LEQUE */
      .hand-container {
        display: flex;
        justify-content: center;
        overflow-x: auto;
        padding: 15px 10px 5px 10px;
        min-height: 90px;
        flex-shrink: 0;
      }

      .cards-row {
        display: flex;
        align-items: flex-end;
        padding-right: 20px;
      }

      /* CARTA PADR√ÉO */
      .carta {
        width: 60px;
        height: 90px;
        background: #fff;
        border-radius: 5px;
        border: 1px solid #000;
        position: relative;
        flex-shrink: 0;
        cursor: pointer;
        box-shadow: -1px 1px 4px rgba(0, 0, 0, 0.3);
        margin-right: -30px;
        transition: transform 0.1s, margin-right 0.1s;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        padding: 2px 4px;
        font-size: 14px;
        font-weight: bold;
      }

      .carta:last-child {
        margin-right: 0;
      }

      #handContainer .carta:hover,
      #handContainer .carta.selected {
        /* transform: translateY(-15px); */
        margin-right: 0;
        z-index: 100;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
      }

      .carta.selected {
        border: 2px solid #facc15;
      }

      /* ==========================
     ANIMA√á√ÉO: carta voadora
     ========================== */
      .fly-card {
        position: fixed;
        left: 0;
        top: 0;
        margin: 0 !important;
        z-index: 9999;
        pointer-events: none;
        transform-origin: top left;
        will-change: transform, opacity;
      }

      /* costas por cor (FINDOM + borda branca) */
      .back-red {
        border: 2px solid #fff !important;
        box-sizing: border-box;

        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 42%), radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0) 55%),
          repeating-linear-gradient(45deg, rgba(255, 215, 0, 0.22) 0 6px, rgba(0, 0, 0, 0) 6px 14px), repeating-linear-gradient(-45deg, rgba(0, 0, 0, 0.22) 0 7px, rgba(0, 0, 0, 0) 7px 16px), linear-gradient(135deg, #140007, #b91c1c) !important;
      }

      .back-blue {
        border: 2px solid #fff !important;
        box-sizing: border-box;

        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 42%), radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0) 55%),
          repeating-linear-gradient(45deg, rgba(192, 192, 192, 0.22) 0 6px, rgba(0, 0, 0, 0) 6px 14px), repeating-linear-gradient(-45deg, rgba(0, 0, 0, 0.22) 0 7px, rgba(0, 0, 0, 0) 7px 16px), linear-gradient(135deg, #05071a, #1d4ed8) !important;
      }

      /* fly-card de costas usa o MESMO visual; e respeita blue se existir */
      .fly-card.back {
        border: 2px solid #fff !important;
        box-sizing: border-box;
      }
      .fly-card.back.back-red {
        background: unset;
      } /* s√≥ pra n√£o ‚Äúprender‚Äù */
      .fly-card.back.back-blue {
        background: unset;
      }
      .fly-card.back {
        /* default: vermelho findom */
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 42%), radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0) 55%),
          repeating-linear-gradient(45deg, rgba(255, 215, 0, 0.22) 0 6px, rgba(0, 0, 0, 0) 6px 14px), repeating-linear-gradient(-45deg, rgba(0, 0, 0, 0.22) 0 7px, rgba(0, 0, 0, 0) 7px 16px), linear-gradient(135deg, #140007, #b91c1c) !important;
      }
      .fly-card.back.back-blue {
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 42%), radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0) 55%),
          repeating-linear-gradient(45deg, rgba(192, 192, 192, 0.22) 0 6px, rgba(0, 0, 0, 0) 6px 14px), repeating-linear-gradient(-45deg, rgba(0, 0, 0, 0.22) 0 7px, rgba(0, 0, 0, 0) 7px 16px), linear-gradient(135deg, #05071a, #1d4ed8) !important;
      }

      /* IMPORTANT√çSSIMO: oponente/morto N√ÉO podem sobrescrever o back */
      .opponent-card-back.back-red,
      .opponent-card-back.back-blue {
        border: 2px solid #fff !important; /* volta borda branca */
        box-sizing: border-box !important;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.7);
      }
      .opponent-card-back.back-red {
        /* reaplica o mesmo tema do .back-red */
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 42%), radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0) 55%),
          repeating-linear-gradient(45deg, rgba(255, 215, 0, 0.22) 0 6px, rgba(0, 0, 0, 0) 6px 14px), repeating-linear-gradient(-45deg, rgba(0, 0, 0, 0.22) 0 7px, rgba(0, 0, 0, 0) 7px 16px), linear-gradient(135deg, #140007, #b91c1c) !important;
      }
      .opponent-card-back.back-blue {
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 42%), radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0) 55%),
          repeating-linear-gradient(45deg, rgba(192, 192, 192, 0.22) 0 6px, rgba(0, 0, 0, 0) 6px 14px), repeating-linear-gradient(-45deg, rgba(0, 0, 0, 0.22) 0 7px, rgba(0, 0, 0, 0) 7px 16px), linear-gradient(135deg, #05071a, #1d4ed8) !important;
      }

      .morto-card-back.back-red {
        border: 1px solid #fff !important;
        box-sizing: border-box !important;
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 42%), radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0) 55%),
          repeating-linear-gradient(45deg, rgba(255, 215, 0, 0.22) 0 6px, rgba(0, 0, 0, 0) 6px 14px), repeating-linear-gradient(-45deg, rgba(0, 0, 0, 0.22) 0 7px, rgba(0, 0, 0, 0) 7px 16px), linear-gradient(135deg, #140007, #b91c1c) !important;
      }
      .morto-card-back.back-blue {
        border: 1px solid #fff !important;
        box-sizing: border-box !important;
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 42%), radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0) 55%),
          repeating-linear-gradient(45deg, rgba(192, 192, 192, 0.22) 0 6px, rgba(0, 0, 0, 0) 6px 14px), repeating-linear-gradient(-45deg, rgba(0, 0, 0, 0.22) 0 7px, rgba(0, 0, 0, 0) 7px 16px), linear-gradient(135deg, #05071a, #1d4ed8) !important;
      }

      /* fly-card de costas: s√≥ esconde face */
      .fly-card.back * {
        visibility: hidden;
      }

      /* ===== IMPACTO + FA√çSCAS ===== */
      .impact-ring {
        position: fixed;
        left: 0;
        top: 0;
        width: 10px;
        height: 10px;
        border-radius: 999px;
        border: 2px solid rgba(250, 204, 21, 0.95);
        box-shadow: 0 0 18px rgba(250, 204, 21, 0.6);
        pointer-events: none;
        z-index: 10000;
        transform: translate(-50%, -50%) scale(0.2);
        opacity: 0.95;
      }

      .spark {
        position: fixed;
        left: 0;
        top: 0;
        width: 6px;
        height: 2px;
        border-radius: 999px;
        background: rgba(250, 204, 21, 1);
        box-shadow: 0 0 10px rgba(250, 204, 21, 0.85);
        pointer-events: none;
        z-index: 10000;
        transform: translate(-50%, -50%);
        opacity: 1;
      }

      .card-impact {
        animation: cardImpact 160ms ease-out;
      }

      @keyframes cardImpact {
        0% {
          transform: translateY(0px) scale(1);
        }
        45% {
          transform: translateY(2px) scale(0.985);
        }
        100% {
          transform: translateY(0px) scale(1);
        }
      }

      /* Destaque tempor√°rio: carta comprada */
      .carta.just-bought {
        border: 2px solid #facc15 !important;
        box-shadow: 0 0 0 4px rgba(250, 204, 21, 0.45), 0 10px 22px rgba(0, 0, 0, 0.65) !important;
        animation: justBoughtGlow 1.2s ease-out forwards;
        z-index: 999;
      }

      @keyframes justBoughtGlow {
        0% {
          transform: translateY(-18px);
          box-shadow: 0 0 0 8px rgba(250, 204, 21, 0.65), 0 14px 28px rgba(0, 0, 0, 0.75);
        }
        100% {
          transform: translateY(0px);
          box-shadow: 0 0 0 0px rgba(250, 204, 21, 0), 0 10px 22px rgba(0, 0, 0, 0.35);
        }
      }

      .hearts,
      .diamonds {
        color: #dc2626;
      }

      .spades,
      .clubs,
      .joker-card {
        color: #000;
      }

      .carta-icone {
        font-size: 20px;
        align-self: flex-end;
        line-height: 1;
      }

      /* MINI CARTA (NA MESA) */
      .carta.mini {
        width: 28px;
        height: 40px;
        margin-right: -14px;
        margin-bottom: 0;
        font-size: 10px;
        padding: 1px;
      }

      .carta.mini .carta-icone {
        font-size: 12px;
      }

      .carta.mini.canastra-fechada {
        transform: rotate(90deg);
        margin-right: -8px;
        margin-bottom: -8px;
      }

      /* PLACAR OVERLAY */
      #scoreSection {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.95);
        z-index: 200;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      @media (max-width: 768px), (max-height: 500px) {
        body {
          font-size: 12px;
        }

        .board {
          overflow-y: auto;
          overflow-x: hidden;
          display: flex;
          flex-direction: column;
        }

        .board-center {
          flex: 1;
          justify-content: space-between;
          padding: 2px 0;
        }

        .board-top {
          padding: 3px 5px;
          height: 36px;
        }

        .opponent-hand-top {
          top: 2px;
        }

        .meld-title {
          font-size: 9px;
        }

        .meld-line {
          min-width: 110px;
          padding: 2px 3px 3px;
        }

        .meld-line-cards {
          height: 28px;
        }

        .carta.mini {
          width: 22px;
          height: 30px;
          margin-right: -9px;
          font-size: 8.5px;
        }

        .board-middle {
          gap: 10px;
          padding: 0;
          margin-top: 4px;
        }

        .pile-card {
          width: 38px;
          height: 54px;
        }

        .pile-info {
          font-size: 9px;
        }

        .hand-container {
          padding: 4px 2px 2px 2px;
          min-height: 60px;
          flex-shrink: 0;
        }

        .opponent-cards {
          gap: 1px;
        }

        .carta {
          width: 42px;
          height: 62px;
          margin-right: -18px;
          font-size: 10px;
        }

        .carta-icone {
          font-size: 13px;
        }

        .player-interface {
          padding: 2px 4px 4px 4px;
          gap: 2px;
        }

        #message {
          font-size: 10px;
          height: 12px;
        }

        .player-actions {
          gap: 4px;
        }

        .player-actions button {
          padding: 4px 6px;
          font-size: 9px;
        }

        #scoreSection .section {
          width: 94%;
          max-width: 380px;
        }
      }

      /* ===========================
   MORTOS (FIX CSS ONLY)
   Morto 1 = vermelho / Morto 2 = azul
   cole no FINAL do CSS
   =========================== */

      #mortoSlot0 .morto-card-back {
        border: 1px solid #fff !important;
        box-sizing: border-box !important;
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 42%), radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0) 55%),
          repeating-linear-gradient(45deg, rgba(255, 215, 0, 0.22) 0 6px, rgba(0, 0, 0, 0) 6px 14px), repeating-linear-gradient(-45deg, rgba(0, 0, 0, 0.22) 0 7px, rgba(0, 0, 0, 0) 7px 16px), linear-gradient(135deg, #140007, #b91c1c) !important;
      }

      #mortoSlot1 .morto-card-back {
        border: 1px solid #fff !important;
        box-sizing: border-box !important;
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 42%), radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0) 55%),
          repeating-linear-gradient(45deg, rgba(192, 192, 192, 0.22) 0 6px, rgba(0, 0, 0, 0) 6px 14px), repeating-linear-gradient(-45deg, rgba(0, 0, 0, 0.22) 0 7px, rgba(0, 0, 0, 0) 7px 16px), linear-gradient(135deg, #05071a, #1d4ed8) !important;
      }
    </style>
  </head>
  <body>
    <div class="app">
      <div id="configSection">
        <div class="section">
          <div class="section-header">
            <h2>Buraco Alpha</h2>
            <small>Configura√ß√£o da sala</small>
          </div>
          <div style="margin-top: 15px; display: flex; flex-direction: column; gap: 10px">
            <label>
              Modo
              <select id="modeSelect">
                <option value="1x1">1x1</option>
                <option value="2x2">2x2</option>
                <option value="1x2">1x2</option>
                <option value="1x1_duploMorto">1x1 Humilha√ß√£o</option>
              </select>
            </label>
            <label>
              Regra
              <select id="variantSelect">
                <option value="aberto">Aberto</option>
                <option value="fechado">Fechado</option>
              </select>
            </label>
            <label>
              Sou
              <select id="localPlayerSelect">
                <option value="0">Jogador 1</option>
                <option value="1">Jogador 2</option>
                <option value="2">Jogador 3</option>
                <option value="3">Jogador 4</option>
              </select>
            </label>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px">
              <input id="p1Name" value="Jogador 1" placeholder="Nome J1" />
              <input id="p2Name" value="Jogador 2" placeholder="Nome J2" />
              <input id="p3Name" value="Jogador 3" placeholder="Nome J3" />
              <input id="p4Name" value="Jogador 4" placeholder="Nome J4" />
            </div>

            <button id="startBtn" style="margin-top: 10px">INICIAR JOGO</button>
            <small style="text-align: center; color: #666">Use o mesmo ID na URL para conectar: ?game=sala1</small>
          </div>
        </div>
      </div>

      <div id="gameSection">
        <div class="board">
          <div class="board-top">
            <div>
              <span class="current-player-chip">
                <span class="current-dot"></span>
                <span id="currentPlayerLabel">...</span>
              </span>
              <span id="turnTimerLabel" style="margin-left: 5px; font-size: 11px; color: #facc15"></span>
            </div>

            <div class="morto-area">
              <div id="mortoSlot0" class="morto-container" title="Morto Time 1">
                <div class="morto-card-back"></div>
                <div class="morto-card-back offset"></div>
                <span class="morto-label">Morto 1</span>
              </div>
              <div id="mortoSlot1" class="morto-container" title="Morto Time 2">
                <div class="morto-card-back"></div>
                <div class="morto-card-back offset"></div>
                <span class="morto-label">Morto 2</span>
              </div>
            </div>
          </div>

          <!-- Oponentes (continuam absolutos por cima da mesa) -->
          <div id="opponentTop" class="opponent-hand opponent-hand-top"></div>
          <div id="opponentLeft" class="opponent-hand opponent-hand-left"></div>
          <div id="opponentRight" class="opponent-hand opponent-hand-right"></div>

          <!-- Centro da mesa: pontos + monte/lixo -->
          <div class="board-center">
            <div class="board-melds">
              <div class="grow">
                <div class="meld-title">
                  <span>Time 1 Pts:</span>
                  <strong id="scoreTeam1">0</strong>
                </div>
                <div id="meldsP1" class="meld-container"></div>
              </div>
              <div class="grow" style="border-left: 1px dashed rgba(255, 255, 255, 0.1); padding-left: 5px">
                <div class="meld-title">
                  <span>Time 2 Pts:</span>
                  <strong id="scoreTeam2">0</strong>
                </div>
                <div id="meldsP2" class="meld-container"></div>
              </div>
            </div>

            <div class="board-middle">
              <div class="pile-area" id="drawStockBtn">
                <div class="pile-card">
                  <div class="pile-card-inner"></div>
                </div>
                <div class="pile-info">
                  Monte (
                  <span id="stockCount">0</span>
                  )
                </div>
              </div>

              <div class="pile-area" id="drawDiscardBtn">
                <div class="pile-card discard-pile">
                  <div id="discardFace" class="discard-face">
                    <div id="discardFaceTop"></div>
                    <div id="discardFaceBottom"></div>
                  </div>
                </div>
                <div class="pile-info">
                  Lixo (
                  <span id="discardCount">0</span>
                  )
                </div>
                <span id="discardTop" style="display: none"></span>
              </div>
            </div>
          </div>

          <!-- √Årea do jogador -->
          <div class="player-interface">
            <div id="message"></div>

            <div class="player-actions">
              <button id="meldBtn">‚¨áÔ∏è Baixar</button>
              <button id="discardBtn">üóëÔ∏è Descartar</button>
              <button id="takeDeadBtn">üíÄ Morto</button>
              <button id="endGameBtn" style="background: #333; font-size: 10px; padding: 8px">‚ùå</button>
            </div>

            <div style="position: absolute; right: 10px; top: 10px; font-size: 10px; color: #aaa">
              <span id="handCountLabel"></span>
            </div>

            <div id="handContainer" class="hand-container">
              <div class="cards-row"></div>
            </div>
          </div>
        </div>
      </div>
      <div id="scoreSection" style="display: none">
        <div class="section" style="width: 90%; max-width: 500px">
          <h2>Fim de Jogo</h2>
          <div id="scoreBoard"></div>
          <button id="closeScoreBtn" style="width: 100%; margin-top: 10px">Fechar</button>
        </div>
      </div>
    </div>

    <script type="module">
      import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js';
      import { getFirestore, doc, setDoc, updateDoc, onSnapshot, deleteDoc } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js';

      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          // SW opcional
        });
      }

      const firebaseConfig = {
        apiKey: 'AIzaSyBHvYOK7pWkikA9x5AjrVjuuSmopHisGik',
        authDomain: 'buraco-27cb3.firebaseapp.com',
        projectId: 'buraco-27cb3',
        storageBucket: 'buraco-27cb3.firebasestorage.app',
        messagingSenderId: '793904091112',
        appId: '1:793904091112:web:3e9f299f5603ee4b6a5e5d',
        measurementId: 'G-Q0RRR9714T',
      };

      const app = initializeApp(firebaseConfig);
      const db = getFirestore(app);

      const urlParams = new URLSearchParams(window.location.search);
      const gameId = urlParams.get('game') || 'teste';
      let myPlayerIndex = parseInt(urlParams.get('player') || '0', 10);

      const gameRef = doc(db, 'buracoGames', gameId);

      const SUITS = ['‚ô£', '‚ô¶', '‚ô•', '‚ô†'];
      const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
      const RANKS_SEQ = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
      const RANKS_SEQ_LOW = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

      const DEAD_CHUNK_SIZE = 11;

      let state = null;
      let selectedHandIndexes = new Set();
      let turnTimerId = null;
      let turnTimerRemaining = 0;
      let selectedMeldTarget = null;
      let lastMyTurn = false; // NOVO: pra saber quando virou a SUA vez
      let lastSeenActionId = null;
      let ignoreOwnActionId = null;

      // ==========================
      // Destaque tempor√°rio: carta comprada
      // ==========================
      let lastBoughtCardId = null;
      let lastBoughtTimer = null;

      function newActionId() {
        return `a_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`;
      }

      function packCard(c) {
        if (!c) return null;
        ensureCardId(c);
        return { id: c.id, rank: c.rank, suit: c.suit, joker: !!c.joker, back: c.back || 'red' };
      }

      function ensureCardId(card) {
        if (!card) return null;
        if (!card.id) card.id = `c_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`;
        return card.id;
      }

      function flashBoughtCard(card) {
        const id = ensureCardId(card);
        if (!id) return;

        lastBoughtCardId = id;

        if (lastBoughtTimer) clearTimeout(lastBoughtTimer);
        lastBoughtTimer = setTimeout(() => {
          lastBoughtCardId = null;
          renderHand();
        }, 1200);

        renderHand(); // renderiza j√° com o highlight
      }

      // ==========================
      // ANIMA√á√ÉO: carta voadora (A -> B)
      // ==========================
      const ANIM_MS = 900;
      const ANIM_EASE = 'cubic-bezier(0.2, 0.8, 0.2, 1)';

      function suitClass(card) {
        return card.joker ? 'joker-card' : card.suit === '‚ô•' || card.suit === '‚ô¶' ? 'hearts' : 'spades';
      }

      function cardFrontHTML(card) {
        return card.joker ? `<div class="carta-canto">JOKER</div><div class="carta-icone">‚òÖ</div>` : `<div class="carta-canto">${card.rank}<br>${card.suit}</div><div class="carta-icone">${card.suit}</div>`;
      }

      function getRect(el) {
        const r = el.getBoundingClientRect();
        return { left: r.left, top: r.top, width: r.width, height: r.height };
      }

      function makeFlyEl(card, face = 'front') {
        const el = document.createElement('div');
        el.className = `carta fly-card ${suitClass(card)}`;

        if (face === 'back') {
          el.classList.add('back');
          el.classList.add(card.back === 'blue' ? 'back-blue' : 'back-red');
        }

        el.innerHTML = cardFrontHTML(card); // n√£o importa, porque .back * fica hidden
        document.body.appendChild(el);
        return el;
      }

      function setBox(el, rect) {
        el.style.left = rect.left + 'px';
        el.style.top = rect.top + 'px';
        el.style.width = rect.width + 'px';
        el.style.height = rect.height + 'px';
      }

      async function flyRectToRect(card, fromRect, toRect, face = 'front') {
        const fly = makeFlyEl(card, face);
        setBox(fly, fromRect);

        const dx = toRect.left - fromRect.left;
        const dy = toRect.top - fromRect.top;
        const sx = toRect.width / fromRect.width;
        const sy = toRect.height / fromRect.height;

        const anim = fly.animate(
          [
            { transform: `translate(0px, 0px) scale(1, 1)`, opacity: 1 },
            { transform: `translate(${dx}px, ${dy}px) scale(${sx}, ${sy})`, opacity: 1 },
          ],
          { duration: ANIM_MS, easing: ANIM_EASE, fill: 'forwards' }
        );

        try {
          await anim.finished;
        } finally {
          fly.remove();
        }
      }

      function impactSparksAt(x, y, opts = {}) {
        const particles = opts.particles ?? 10;
        const dist = opts.dist ?? 32;
        const dur = opts.dur ?? 320;

        // anel (pancada)
        const ring = document.createElement('div');
        ring.className = 'impact-ring';
        ring.style.left = x + 'px';
        ring.style.top = y + 'px';
        document.body.appendChild(ring);

        ring
          .animate(
            [
              { transform: 'translate(-50%, -50%) scale(0.15)', opacity: 0.95 },
              { transform: 'translate(-50%, -50%) scale(1.25)', opacity: 0.0 },
            ],
            { duration: dur, easing: 'cubic-bezier(.2,.9,.2,1)', fill: 'forwards' }
          )
          .finished.finally(() => ring.remove());

        // fa√≠scas
        for (let i = 0; i < particles; i++) {
          const sp = document.createElement('div');
          sp.className = 'spark';
          sp.style.left = x + 'px';
          sp.style.top = y + 'px';
          document.body.appendChild(sp);

          const ang = Math.random() * Math.PI * 2;
          const d = dist * (0.55 + Math.random() * 0.75);
          const dx = Math.cos(ang) * d;
          const dy = Math.sin(ang) * d;
          const rot = Math.random() * 160 - 80;

          sp.animate(
            [
              { transform: `translate(-50%, -50%) rotate(${rot}deg) translate(0px,0px)`, opacity: 1 },
              { transform: `translate(-50%, -50%) rotate(${rot}deg) translate(${dx}px,${dy}px)`, opacity: 0 },
            ],
            { duration: dur, easing: 'cubic-bezier(.2,.9,.2,1)', fill: 'forwards' }
          ).finished.finally(() => sp.remove());
        }
      }

      function impactAtRect(toRect) {
        if (!toRect) return;
        const x = toRect.left + toRect.width / 2;
        const y = toRect.top + toRect.height / 2;
        impactSparksAt(x, y, { particles: 10, dist: 34, dur: 320 });
      }

      function cardElById(cardId) {
        return document.querySelector(`#handContainer .carta[data-card-id="${cardId}"]`);
      }

      function meldElByKey(key) {
        return document.querySelector(`.meld-line[data-meld-key="${key}"]`);
      }

      function meldDropRect(key, offset = 0) {
        const meldEl = meldElByKey(key);
        const row = meldEl ? meldEl.querySelector('.meld-line-cards') : null;
        const r = row ? row.getBoundingClientRect() : null;
        if (!r) return null;

        // ‚Äúfim do trilho‚Äù + offset pra m√∫ltiplas cartas n√£o ca√≠rem no mesmo pixel
        return { left: r.left + r.width - 28 - offset, top: r.top, width: 28, height: 40 };
      }

      function updateTimerLabel() {
        const el = document.getElementById('turnTimerLabel');
        if (!el) return;
        if (!state || state.finished || state.currentPlayer !== myPlayerIndex) {
          el.textContent = '';
          return;
        }
        el.textContent = `${turnTimerRemaining}s`;
      }

      function stopTurnTimer() {
        if (turnTimerId !== null) {
          clearInterval(turnTimerId);
          turnTimerId = null;
        }
      }

      let committing = false;
      let pendingCommit = false;

      async function commitState() {
        if (!state) return;

        pendingCommit = true;
        if (committing) return;

        committing = true;
        try {
          while (pendingCommit) {
            pendingCommit = false;
            await updateDoc(gameRef, {
              stateJson: JSON.stringify(state),
              updatedAt: Date.now(),
            });
          }
        } catch (err) {
          console.error('commitState failed:', err);
        } finally {
          committing = false;
        }
      }

      async function autoPlayTimeout() {
        if (!ensureMyTurn()) return;
        if (!state.hasDrawnThisTurn) {
          if (!state.stock.length) recycleDeadToStockIfPossible();
          if (state.stock.length) {
            const c = state.stock.pop();
            const me = currentPlayer();
            me.hand.push(c);
            sortHand(me.hand);
            state.hasDrawnThisTurn = true;
          } else if (state.discard.length && state.variant === 'aberto') {
            const c = state.discard.pop();
            const me = currentPlayer();
            me.hand.push(c);
            sortHand(me.hand);
            state.hasDrawnThisTurn = true;
          }
        }
        const me = currentPlayer();
        const hand = me.hand;
        if (!hand.length) {
          await commitState();
          return;
        }
        if (state.variant === 'fechado' && state.requiredDiscardCard) {
          showMessage('Tempo esgotado, obrigat√≥rio usar descarte (regra fechada).');
          return;
        }
        const idx = Math.floor(Math.random() * hand.length);
        const card = hand.splice(idx, 1)[0];
        state.discard.push(card);

        const teamId = me.teamId;
        const taken = state.deadChunksTaken?.[teamId] ?? 0;
        const max = state.deadChunksMax?.[teamId] ?? 1;

        if (hand.length === 0 && taken >= max) {
          await finishGame(teamId);
          return;
        }

        if (state.mode === '1x1_duploMorto') {
          if (state.currentPlayer === 1) {
            if (!state.j2ConsecutiveTurns || state.j2ConsecutiveTurns === 0) {
              state.j2ConsecutiveTurns = 1;
            } else {
              state.currentPlayer = 0;
              state.j2ConsecutiveTurns = 0;
            }
          } else {
            state.currentPlayer = 1;
            state.j2ConsecutiveTurns = 0;
          }
        } else {
          state.currentPlayer = (state.currentPlayer + 1) % state.players.length;
        }

        state.hasDrawnThisTurn = false;
        state.requiredDiscardCard = null;
        showMessage('Tempo esgotado: auto-play.');
        await commitState();
      }

      function classifyMeldForUi(meld) {
        if (!meld || meld.length < 7) return { kind: 'simple', base: 'Jogo', tag: null };
        const hasWild = hasRealWild(meld);
        const nonJoker = meld.filter((c) => !c.joker);
        if (!nonJoker.length) return { kind: 'simple', base: 'Jogo', tag: null };

        const orderLow = {};
        RANKS_SEQ_LOW.forEach((r, i) => (orderLow[r] = i));
        const orderHigh = {};
        RANKS_SEQ.forEach((r, i) => (orderHigh[r] = i));

        const sortedLow = nonJoker.slice().sort((a, b) => orderLow[a.rank] - orderLow[b.rank]);
        const ranksLow = sortedLow.map((c) => c.rank);
        const aceCount = ranksLow.filter((r) => r === 'A').length;
        const uniqueIdxsLow = [...new Set(ranksLow.map((r) => orderLow[r]))];
        let contiguousLow = true;
        for (let i = 1; i < uniqueIdxsLow.length; i++) if (uniqueIdxsLow[i] !== uniqueIdxsLow[i - 1] + 1) contiguousLow = false;

        const sortedHigh = nonJoker.slice().sort((a, b) => orderHigh[a.rank] - orderHigh[b.rank]);
        const ranksHigh = sortedHigh.map((c) => c.rank);
        const uniqueIdxsHigh = [...new Set(ranksHigh.map((r) => orderHigh[r]))];
        let contiguousHigh = true;
        for (let i = 1; i < uniqueIdxsHigh.length; i++) if (uniqueIdxsHigh[i] !== uniqueIdxsHigh[i - 1] + 1) contiguousHigh = false;

        const firstRankLow = ranksLow[0];
        const lastRankLow = ranksLow[ranksLow.length - 1];
        const firstRankHigh = ranksHigh[0];
        const lastRankHigh = ranksHigh[ranksHigh.length - 1];
        const hasKing = ranksLow.includes('K') || ranksHigh.includes('K');
        const contiguous = contiguousLow || contiguousHigh;

        if (hasWild) return { kind: 'suja', base: 'Canastra', tag: { cls: 'suja', text: 'Suja' } };
        if (!contiguous) return { kind: 'simple', base: 'Jogo', tag: null };

        let isReal = false;
        let isAsAs = false;
        if (aceCount >= 2 && firstRankLow === 'A' && lastRankHigh === 'A' && hasKing && contiguousLow && contiguousHigh && ranksLow.length >= 8) isAsAs = true;
        else if (aceCount === 1 && firstRankLow === 'A' && lastRankLow === 'K' && contiguousLow && ranksLow.length >= 7) isReal = true;

        if (isAsAs) return { kind: 'asas', base: 'C. √Ås-√Ås', tag: { cls: 'real', text: 'Real' } };
        if (isReal) return { kind: 'real', base: 'C. Real', tag: { cls: 'real', text: 'Real' } };

        return { kind: 'limpa', base: 'Canastra', tag: { cls: 'limpa', text: 'Limpa' } };
      }

      function startTurnTimerIfNeeded() {
        stopTurnTimer();
        if (!state || state.finished || state.currentPlayer !== myPlayerIndex) {
          updateTimerLabel();
          return;
        }
        turnTimerRemaining = 60;
        updateTimerLabel();
        turnTimerId = setInterval(() => {
          turnTimerRemaining--;
          if (turnTimerRemaining <= 0) {
            stopTurnTimer();
            autoPlayTimeout().catch(console.error);
          } else {
            updateTimerLabel();
          }
        }, 1000);
      }

      function createDeck() {
        const deck = [];
        for (let d = 0; d < 2; d++) {
          const back = d === 0 ? 'red' : 'blue'; // ‚úÖ 50/50
          for (const s of SUITS) {
            for (const r of RANKS) deck.push({ rank: r, suit: s, joker: false, back });
          }
          deck.push({ rank: 'JOKER', suit: '‚òÖ', joker: true, back });
          deck.push({ rank: 'JOKER', suit: '‚òÖ', joker: true, back });
        }
        return deck;
      }

      function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }

      function recycleDeadToStockIfPossible() {
        if (!state || state.stock.length) return false;
        let collected = [];
        if (state.deadPiles && state.deadPiles.length) {
          state.deadPiles.forEach((pile, idx) => {
            if (pile && pile.length) {
              collected = collected.concat(pile);
              state.deadPiles[idx] = [];
              if (state.deadChunksTaken && state.deadChunksMax) state.deadChunksTaken[idx] = state.deadChunksMax[idx] ?? state.deadChunksTaken[idx];
            }
          });
        }
        if (!collected.length) return false;
        shuffle(collected);
        state.stock = collected;
        return true;
      }

      function cardLabel(card) {
        if (card.joker) return 'JOKER';
        return card.rank + card.suit;
      }

      function isWildcard(card, meld = null) {
        if (!card) return false;
        if (card.joker) return true;
        if (card.rank !== '2') return false;
        if (!meld || !Array.isArray(meld)) return true;
        const sameSuitRanks = meld.filter((c) => !c.joker && c.suit === card.suit).map((c) => c.rank);
        const hasAce = sameSuitRanks.includes('A');
        const hasThree = sameSuitRanks.includes('3');
        if (hasAce && hasThree) return false;
        return true;
      }

      function cardBasePoints(card) {
        if (card.joker) return 20;
        if (card.rank === 'A' || card.rank === '2') return 15;
        if (['3', '4', '5', '6', '7'].includes(card.rank)) return 5;
        return 10;
      }

      function hasRealWild(meld) {
        return meld.some((c) => isWildcard(c, meld));
      }

      function sortHand(hand) {
        const rankOrder = {};
        RANKS_SEQ.forEach((r, idx) => (rankOrder[r] = idx));
        hand.sort((a, b) => {
          if (a.joker && !b.joker) return 1;
          if (!a.joker && b.joker) return -1;
          if (a.suit === b.suit) return rankOrder[a.rank] - rankOrder[b.rank];
          return SUITS.indexOf(a.suit) - SUITS.indexOf(b.suit);
        });
      }

      async function startGame(mode, names, variant) {
        if (myPlayerIndex !== 0) {
          showMessage('S√≥ Jogador 1 inicia.');
          return;
        }
        const players = [];
        const teams = [];
        let playerConfigs = [];
        if (mode === '1x1' || mode === '1x1_duploMorto') {
          playerConfigs = [
            { name: names[0] || 'J1', team: 0 },
            { name: names[1] || 'J2', team: 1 },
          ];
        } else if (mode === '2x2') {
          playerConfigs = [
            { name: names[0] || 'J1', team: 0 },
            { name: names[1] || 'J2', team: 1 },
            { name: names[2] || 'J3', team: 0 },
            { name: names[3] || 'J4', team: 1 },
          ];
        } else if (mode === '1x2') {
          playerConfigs = [
            { name: names[0] || 'Solo', team: 0 },
            { name: names[1] || 'D1', team: 1 },
            { name: names[2] || 'D2', team: 1 },
          ];
        }
        playerConfigs.forEach((cfg, idx) => {
          players.push({ id: idx, name: cfg.name, teamId: cfg.team, hand: [] });
        });
        for (let t = 0; t < 2; t++) {
          const playerIndexes = players.filter((p) => p.teamId === t).map((p) => p.id);
          teams.push({ id: t, name: t === 0 ? 'Time 1' : 'Time 2', playerIndexes, melds: [] });
        }
        let stock = shuffle(createDeck());
        const discard = [];
        const deadPiles = [[], []];
        const HAND_SIZE = 11;
        for (let i = 0; i < HAND_SIZE; i++) for (let pIdx = 0; pIdx < players.length; pIdx++) players[pIdx].hand.push(stock.pop());
        for (let i = 0; i < DEAD_CHUNK_SIZE; i++) {
          deadPiles[0].push(stock.pop());
          deadPiles[1].push(stock.pop());
        }
        players.forEach((p) => sortHand(p.hand));
        discard.push(stock.pop());
        let deadChunksMax = [1, 1];
        if (mode === '1x1_duploMorto') deadChunksMax = [1, 2];
        const newState = {
          mode,
          variant,
          players,
          teams,
          currentPlayer: 0,
          stock,
          discard,
          deadPiles,
          deadChunksTaken: [0, 0],
          deadChunksMax,
          hasDrawnThisTurn: false,
          finished: false,
          winnerTeamId: null,
          j2ConsecutiveTurns: 0,
          requiredDiscardCard: null,
        };
        await setDoc(gameRef, { stateJson: JSON.stringify(newState), createdAt: Date.now() });
        showMessage('Partida iniciada!');
      }

      function currentPlayer() {
        return state.players[state.currentPlayer];
      }
      function currentTeam() {
        return state.teams[currentPlayer().teamId];
      }
      function ensureMyTurn() {
        if (!state || state.finished) {
          showMessage('Fim de jogo.');
          return false;
        }
        if (state.currentPlayer !== myPlayerIndex) {
          showMessage('Aguarde sua vez.');
          return false;
        }
        return true;
      }

      async function drawFromStock() {
        if (!ensureMyTurn()) return;
        if (state.hasDrawnThisTurn) {
          showMessage('J√° comprou.');
          return;
        }

        const fromEl = document.querySelector('#drawStockBtn .pile-card');
        const fromRect = fromEl ? getRect(fromEl) : null;

        if (!state.stock.length) {
          if (!recycleDeadToStockIfPossible() || !state.stock.length) {
            showMessage('Monte vazio.');
            return;
          } else showMessage('Morto virou monte.');
        }

        const c = state.stock.pop();
        ensureCardId(c);

        currentPlayer().hand.push(c);
        sortHand(currentPlayer().hand);
        state.hasDrawnThisTurn = true;

        // render pra achar o destino no DOM
        lastBoughtCardId = null;
        renderHand();

        const toEl = cardElById(c.id);
        if (fromRect && toEl) {
          const toRect = getRect(toEl);
          toEl.style.visibility = 'hidden';
          await flyRectToRect(c, fromRect, toRect, 'back'); // do monte: eu animaria ‚Äúverso‚Äù
          toEl.style.visibility = '';
        }

        flashBoughtCard(c);

        state.lastAction = { id: newActionId(), type: 'drawStock', playerId: state.currentPlayer, card: packCard(c), ts: Date.now() };
        ignoreOwnActionId = state.lastAction.id;

        // BUG REAL: antes voc√™ n√£o commitava compra do monte (outros players n√£o veem)
        await commitState();
      }

      function canUseDiscardInClosed(discardTop, hand, team) {
        if (!discardTop) return false;
        const n = hand.length;
        const pool = hand.concat([discardTop]);
        const idxTopo = pool.length - 1;
        const totalMasks = 1 << pool.length;
        for (let mask = 0; mask < totalMasks; mask++) {
          if (!(mask & (1 << idxTopo))) continue;
          const subset = [];
          for (let i = 0; i < pool.length; i++) if (mask & (1 << i)) subset.push(pool[i]);
          if (subset.length >= 3 && isValidSequenceMeld(subset)) return true;
        }
        if (team && team.melds && team.melds.length) {
          for (const meld of team.melds) {
            const base = meld;
            const maxMask2 = 1 << n;
            for (let mask = 0; mask < maxMask2; mask++) {
              const subset = base.slice();
              subset.push(discardTop);
              for (let i = 0; i < n; i++) if (mask & (1 << i)) subset.push(hand[i]);
              if (isValidSequenceMeld(subset)) return true;
            }
          }
        }
        return false;
      }

      async function drawFromDiscard() {
        if (!ensureMyTurn()) return;
        if (state.hasDrawnThisTurn) {
          showMessage('J√° comprou.');
          return;
        }
        if (!state.discard.length) {
          showMessage('Lixo vazio.');
          return;
        }

        const fromEl = document.getElementById('discardFace');
        const fromRect = fromEl ? getRect(fromEl) : null;

        const top = state.discard[state.discard.length - 1];
        ensureCardId(top);
        const me = currentPlayer();

        if (state.variant === 'fechado') {
          const canUse = canUseDiscardInClosed(top, me.hand, currentTeam());
          if (!canUse) {
            showMessage('Fechado: a carta deve servir p/ jogo.');
            return;
          }
        }

        const pile = state.discard.splice(0, state.discard.length);
        pile.forEach(ensureCardId);

        me.hand.push(...pile);
        sortHand(me.hand);

        state.hasDrawnThisTurn = true;
        if (state.variant === 'fechado') state.requiredDiscardCard = { rank: top.rank, suit: top.suit, joker: !!top.joker };
        else state.requiredDiscardCard = null;

        // render pra achar destino do "top" no DOM
        lastBoughtCardId = null;
        renderHand();

        const toEl = cardElById(top.id);
        if (fromRect && toEl) {
          const toRect = getRect(toEl);
          toEl.style.visibility = 'hidden';
          await flyRectToRect(top, fromRect, toRect, 'front'); // do lixo: faz sentido mostrar a face
          toEl.style.visibility = '';
        }

        flashBoughtCard(top);

        state.lastAction = { id: newActionId(), type: 'drawDiscard', playerId: state.currentPlayer, card: packCard(top), ts: Date.now() };
        ignoreOwnActionId = state.lastAction.id;

        await commitState();
      }

      function isValidSequenceMeld(cards) {
        if (!cards || cards.length < 3) return false;
        const wildCards = cards.filter((c) => isWildcard(c, cards));
        if (wildCards.length > 1) return false;
        const nonWild = cards.filter((c) => !isWildcard(c, cards));
        if (!nonWild.length) return false;
        const suit = nonWild[0].suit;
        if (!nonWild.every((c) => c.suit === suit)) return false;
        const availableWilds = cards.length - nonWild.length;

        function neededWildsForOrder(order, aceMode) {
          const seqOrder = {};
          order.forEach((r, i) => (seqOrder[r] = i));
          const sorted = nonWild.slice().sort((a, b) => seqOrder[a.rank] - seqOrder[b.rank]);
          const acePosInOrder = seqOrder['A'];
          const aceIndex = sorted.findIndex((c) => c.rank === 'A');
          if (aceIndex !== -1) {
            if (aceMode === 'high' && aceIndex !== sorted.length - 1) return null;
            if (aceMode === 'low' && aceIndex !== 0) return null;
            if (aceMode === 'none') return null;
          }
          let needed = 0;
          for (let i = 1; i < sorted.length; i++) {
            const prev = seqOrder[sorted[i - 1].rank];
            const curr = seqOrder[sorted[i].rank];
            if (prev == null || curr == null) return null;
            const diff = curr - prev;
            if (diff <= 0) return null;
            if (diff > 1) needed += diff - 1;
          }
          return needed;
        }
        const needHigh = neededWildsForOrder(RANKS_SEQ, 'high');
        const needLow = neededWildsForOrder(RANKS_SEQ_LOW, 'low');
        return (needHigh !== null && needHigh <= availableWilds) || (needLow !== null && needLow <= availableWilds);
      }

      async function attemptExtendExistingMeld(cards, indexes) {
        const team = currentTeam();
        if (!team.melds || !team.melds.length) return false;
        const hand = currentPlayer().hand;
        let forcedIndex = null;
        if (selectedMeldTarget) {
          const [teamIdStr, meldIdxStr] = selectedMeldTarget.split(':');
          if (parseInt(teamIdStr) === team.id && team.melds[parseInt(meldIdxStr)]) forcedIndex = parseInt(meldIdxStr);
        }
        if (forcedIndex !== null) {
          const targetMeld = team.melds[forcedIndex];
          const combined = targetMeld.concat(cards);
          if (!isValidSequenceMeld(combined)) {
            showMessage('N√£o encaixa.');
            return false;
          }

          const key = team.id + ':' + forcedIndex;
          const baseDrop = meldDropRect(key, 0);
          if (baseDrop) {
            const anims = cards.map((c, i) => {
              const from = cardElById(c.id);
              if (!from) return Promise.resolve();
              const fromRect = getRect(from);
              from.style.visibility = 'hidden';
              const toRect = { ...baseDrop, left: baseDrop.left - i * 10, top: baseDrop.top + i * 2 };
              return flyRectToRect(c, fromRect, toRect, 'front').then(() => impactAtRect(toRect));
            });
            await Promise.all(anims);
          }

          for (const idx of indexes) {
            targetMeld.push(hand[idx]);
            hand.splice(idx, 1);
          }
          normalizeMeldOrder(targetMeld);
          sortHand(hand);
          selectedHandIndexes.clear();
          selectedMeldTarget = null;

          // üî• avisa os outros o que aconteceu
          state.lastAction = {
            id: newActionId(),
            type: 'meldExtend',
            playerId: myPlayerIndex, // ou state.currentPlayer (os 2 batem na tua vez)
            teamId: team.id,
            meldIndex: forcedIndex,
            cards: cards.map(packCard),
            ts: Date.now(),
          };
          ignoreOwnActionId = state.lastAction.id;

          await commitState();
          showMessage('Cartas adicionadas!');
          return true;
        }
        const candidateMeldIndexes = [];
        team.melds.forEach((meld, idx) => {
          if (isValidSequenceMeld(meld.concat(cards))) candidateMeldIndexes.push(idx);
        });
        if (!candidateMeldIndexes.length) return false;
        if (candidateMeldIndexes.length > 1) {
          showMessage('Encaixa em v√°rios. Selecione o jogo.');
          return false;
        }
        const teamMeld = team.melds[candidateMeldIndexes[0]];
        const key = team.id + ':' + candidateMeldIndexes[0];

        for (const idx of indexes) {
          teamMeld.push(hand[idx]);
          hand.splice(idx, 1);
        }
        normalizeMeldOrder(teamMeld);
        sortHand(hand);
        selectedHandIndexes.clear();
        selectedMeldTarget = null;

        // üî• avisa os outros o que aconteceu
        state.lastAction = {
          id: newActionId(),
          type: 'meldExtend',
          playerId: myPlayerIndex,
          teamId: team.id,
          meldIndex: candidateMeldIndexes[0],
          cards: cards.map(packCard),
          ts: Date.now(),
        };
        ignoreOwnActionId = state.lastAction.id;

        await commitState();
        return true;
      }

      async function makeMeldFromSelection() {
        if (!ensureMyTurn()) return;
        if (!state.hasDrawnThisTurn) {
          showMessage('Compre primeiro.');
          return;
        }

        const hand = currentPlayer().hand;
        const indexes = Array.from(selectedHandIndexes).sort((a, b) => b - a);

        if (!indexes.length) {
          showMessage('Selecione cartas.');
          return;
        }

        const cards = indexes.map((i) => hand[i]);

        const extended = await attemptExtendExistingMeld(cards, indexes);
        if (extended) return;

        if (indexes.length < 3) {
          showMessage('Novo jogo: m√≠n 3 cartas.');
          return;
        }

        if (!isValidSequenceMeld(cards)) {
          showMessage('Sequ√™ncia inv√°lida.');
          return;
        }

        // ===== 5.4B: ANIMA√á√ÉO (m√£o -> √°rea de jogos do time) =====
        cards.forEach(ensureCardId);

        const teamId = currentTeam().id;
        const targetContainer = document.getElementById(teamId === 0 ? 'meldsP1' : 'meldsP2');

        if (targetContainer) {
          const tr = targetContainer.getBoundingClientRect();
          const dropBase = { left: tr.left + tr.width - 30, top: tr.top + 10, width: 22, height: 30 };

          const anims = cards.map((c, i) => {
            const from = cardElById(c.id);
            if (!from) return Promise.resolve();

            const fromRect = getRect(from);
            from.style.visibility = 'hidden';

            const toRect = { ...dropBase, left: dropBase.left - i * 10, top: dropBase.top + i * 2 };
            return flyRectToRect(c, fromRect, toRect, 'front').then(() => impactAtRect(toRect));
          });

          await Promise.all(anims);
        }
        // ===== fim anima√ß√£o =====

        const meld = [];
        for (const idx of indexes) {
          meld.unshift(hand[idx]);
          hand.splice(idx, 1);
        }

        normalizeMeldOrder(meld);

        // adiciona o jogo no state
        const teamId2 = currentTeam().id;
        currentTeam().melds.push(meld);

        // calcula a key do meld rec√©m criado (importante pro meldDropRect funcionar)
        const meldIdx = currentTeam().melds.length - 1;
        const meldKey = teamId2 + ':' + meldIdx;

        // üî• PUBLICA A A√á√ÉO PROS OUTROS ANIMAREM
        state.lastAction = {
          id: newActionId(),
          type: 'meldNew',
          playerId: myPlayerIndex,
          teamId: currentTeam().id,
          meldIndex: meldIdx, // ‚úÖ ADICIONA ISSO
          cards: cards.map(packCard),
          ts: Date.now(),
        };

        ignoreOwnActionId = state.lastAction.id;

        selectedHandIndexes.clear();
        await commitState();
      }

      async function takeDead() {
        if (!ensureMyTurn()) return;
        const p = currentPlayer();
        const teamId = p.teamId;
        const taken = state.deadChunksTaken?.[teamId] ?? 0;
        const max = state.deadChunksMax?.[teamId] ?? 1;
        if (taken >= max) {
          showMessage('Sem mortos p/ sua equipe.');
          return;
        }
        if (p.hand.length > 0) {
          showMessage('M√£o deve estar vazia.');
          return;
        }
        let deadIndex = teamId;
        if (state.mode === '1x1_duploMorto' && teamId === 1 && taken >= 1) {
          if (!state.deadPiles[deadIndex].length) deadIndex = 0;
        }
        const dead = state.deadPiles[deadIndex];
        if (!dead || !dead.length) {
          showMessage('Morto vazio.');
          return;
        }
        const chunkSize = Math.min(DEAD_CHUNK_SIZE, dead.length);
        const fromSlot = document.getElementById(deadIndex === 0 ? 'mortoSlot0' : 'mortoSlot1');
        const handArea = document.getElementById('handContainer');

        if (fromSlot && handArea) {
          const fr = fromSlot.getBoundingClientRect();
          const hr = handArea.getBoundingClientRect();

          // anima s√≥ ‚Äúuma carta‚Äù do morto (stack fake)
          const fakeCard = { rank: '‚òÖ', suit: '‚òÖ', joker: true, id: `dead_${Date.now()}` };
          const fromRect = { left: fr.left, top: fr.top, width: fr.width, height: fr.height };
          const toRect = { left: hr.left + hr.width * 0.5, top: hr.top + 10, width: 60, height: 90 };

          await flyRectToRect(fakeCard, fromRect, toRect, 'back');
        }

        p.hand = dead.splice(0, chunkSize);
        sortHand(p.hand);
        state.deadChunksTaken[teamId] = taken + 1;

        state.lastAction = {
          id: newActionId(),
          type: 'takeDead',
          playerId: state.currentPlayer,
          deadIndex,
          count: chunkSize,
          ts: Date.now(),
        };
        ignoreOwnActionId = state.lastAction.id;

        await commitState();
      }

      async function discardSelectedCard() {
        if (!ensureMyTurn()) return;
        if (!state.hasDrawnThisTurn) {
          showMessage('Compre primeiro.');
          return;
        }

        if (state.variant === 'fechado' && state.requiredDiscardCard) {
          const must = state.requiredDiscardCard;
          const stillInHand = currentPlayer().hand.some((c) => c.rank === must.rank && c.suit === must.suit && !!c.joker === !!must.joker);
          if (stillInHand) {
            showMessage('Use a carta do lixo antes.');
            return;
          }
        }

        const hand = currentPlayer().hand;
        const indexes = Array.from(selectedHandIndexes);
        if (indexes.length !== 1) {
          showMessage('Selecione 1 carta.');
          return;
        }

        const index = indexes[0];
        const card = hand[index];
        ensureCardId(card);

        const fromEl = cardElById(card.id);
        const toEl = document.getElementById('discardFace');

        if (fromEl && toEl) {
          const fromRect = getRect(fromEl);
          const toRect = getRect(toEl);
          fromEl.style.visibility = 'hidden';
          await flyRectToRect(card, fromRect, toRect, 'front');
        }

        // agora sim: mexe no state
        hand.splice(index, 1);
        state.discard.push(card);
        selectedHandIndexes.clear();

        const teamId = currentPlayer().teamId;
        const taken = state.deadChunksTaken?.[teamId] ?? 0;
        const max = state.deadChunksMax?.[teamId] ?? 1;
        if (hand.length === 0 && taken >= max) {
          await finishGame(teamId);
          return;
        }

        if (state.mode === '1x1_duploMorto') {
          if (state.currentPlayer === 1) {
            state.j2ConsecutiveTurns = !state.j2ConsecutiveTurns ? 1 : 0;
            if (state.j2ConsecutiveTurns === 0) state.currentPlayer = 0;
          } else {
            state.currentPlayer = 1;
            state.j2ConsecutiveTurns = 0;
          }
        } else {
          state.currentPlayer = (state.currentPlayer + 1) % state.players.length;
        }

        state.requiredDiscardCard = null;
        state.hasDrawnThisTurn = false;

        state.lastAction = {
          id: newActionId(),
          type: 'discard',
          playerId: myPlayerIndex, // quem descartou
          card: packCard(card),
          ts: Date.now(),
        };
        ignoreOwnActionId = state.lastAction.id;

        await commitState();
      }

      function computeTeamMeldScore(team) {
        let meldPoints = 0,
          sujaBonus = 0,
          limpaBonus = 0,
          realBonus = 0,
          asasBonus = 0;
        if (!team || !team.melds) return { total: 0 };
        team.melds.forEach((meld) => {
          meld.forEach((c) => (meldPoints += cardBasePoints(c)));
          if (meld.length >= 7) {
            const info = classifyMeldForUi(meld);
            if (info.kind === 'suja') sujaBonus += 100;
            if (info.kind === 'limpa') limpaBonus += 200;
            if (info.kind === 'real') realBonus += 500;
            if (info.kind === 'asas') asasBonus += 1000;
          }
        });
        return { meldPoints, sujaBonus, limpaBonus, realBonus, asasBonus, total: meldPoints + sujaBonus + limpaBonus + realBonus + asasBonus };
      }

      function normalizeMeldOrder(meld) {
        // (L√≥gica complexa de ordena√ß√£o mantida intacta)
        if (!meld || !meld.length) return;
        const nonWild = meld.filter((c) => !isWildcard(c, meld));
        const wild = meld.filter((c) => isWildcard(c, meld));
        if (!nonWild.length) {
          meld.splice(0, meld.length, ...wild);
          return;
        }
        const availableWilds = wild.length;
        function neededWildsForOrder(order, aceMode) {
          const seqOrder = {};
          order.forEach((r, i) => (seqOrder[r] = i));
          const sorted = nonWild.slice().sort((a, b) => seqOrder[a.rank] - seqOrder[b.rank]);
          const aceIndex = sorted.findIndex((c) => c.rank === 'A');
          if (aceIndex !== -1) {
            if (aceMode === 'high' && aceIndex !== sorted.length - 1) return null;
            if (aceMode === 'low' && aceIndex !== 0) return null;
            if (aceMode === 'none') return null;
          }
          let needed = 0;
          for (let i = 1; i < sorted.length; i++) {
            const diff = seqOrder[sorted[i].rank] - seqOrder[sorted[i - 1].rank];
            if (diff <= 0) return null;
            if (diff > 1) needed += diff - 1;
          }
          return needed;
        }
        const needHigh = neededWildsForOrder(RANKS_SEQ, 'high');
        const needLow = neededWildsForOrder(RANKS_SEQ_LOW, 'low');
        const okHigh = needHigh !== null && needHigh <= availableWilds;
        const okLow = needLow !== null && needLow <= availableWilds;

        let order, aceMode;
        if (okHigh && okLow) {
          if (needHigh <= needLow) {
            order = RANKS_SEQ;
            aceMode = 'high';
          } else {
            order = RANKS_SEQ_LOW;
            aceMode = 'low';
          }
        } else if (okHigh) {
          order = RANKS_SEQ;
          aceMode = 'high';
        } else if (okLow) {
          order = RANKS_SEQ_LOW;
          aceMode = 'low';
        } else return;

        const seqOrder = {};
        order.forEach((r, i) => (seqOrder[r] = i));
        const sortedNonWild = nonWild.slice().sort((a, b) => seqOrder[a.rank] - seqOrder[b.rank]);
        const middle = [];
        const wildQueue = [...wild];
        for (let i = 0; i < sortedNonWild.length; i++) {
          middle.push(sortedNonWild[i]);
          if (i < sortedNonWild.length - 1) {
            let gap = seqOrder[sortedNonWild[i + 1].rank] - seqOrder[sortedNonWild[i].rank] - 1;
            while (gap > 0 && wildQueue.length) {
              middle.push(wildQueue.shift());
              gap--;
            }
          }
        }
        const prefix = [];
        const suffix = [];
        if (aceMode === 'high') {
          while (wildQueue.length) prefix.push(wildQueue.shift());
        } else {
          while (wildQueue.length) suffix.push(wildQueue.shift());
        }
        meld.splice(0, meld.length, ...prefix, ...middle, ...suffix);
      }

      function computeScores() {
        const results = [];
        state.teams.forEach((team) => {
          const players = state.players.filter((p) => p.teamId === team.id);
          let handPenalty = 0;
          players.forEach((p) => p.hand.forEach((c) => (handPenalty += cardBasePoints(c))));
          const meldInfo = computeTeamMeldScore(team);
          results.push({ team, players, score: meldInfo.total - handPenalty, handPenalty, ...meldInfo });
        });
        return results;
      }

      async function finishGame(winnerTeamId) {
        if (!state) return;
        state.finished = true;
        state.winnerTeamId = winnerTeamId ?? null;
        await commitState();
      }

      // RENDER
      function renderAll() {
        if (!state) return;
        document.getElementById('currentPlayerLabel').textContent = currentPlayer().name;
        document.getElementById('stockCount').textContent = state.stock.length;

        // Descarte
        const discardTop = state.discard[state.discard.length - 1];
        document.getElementById('discardCount').textContent = state.discard.length;
        const discardFace = document.getElementById('discardFace');
        const fTop = document.getElementById('discardFaceTop');
        const fBot = document.getElementById('discardFaceBottom');
        if (!discardTop) discardFace.style.display = 'none';
        else {
          discardFace.style.display = 'flex';
          if (discardTop.joker) {
            fTop.textContent = '‚òÖ';
            fBot.textContent = '‚òÖ';
            discardFace.style.color = '#b45309';
          } else {
            fTop.innerHTML = discardTop.rank + '<br>' + discardTop.suit;
            fBot.textContent = discardTop.suit;
            discardFace.style.color = discardTop.suit === '‚ô•' || discardTop.suit === '‚ô¶' ? '#b91c1c' : '#000';
          }
        }

        // Mortos
        const s0 = document.getElementById('mortoSlot0');
        const s1 = document.getElementById('mortoSlot1');
        if (state.deadPiles.length >= 2) {
          s0.classList.toggle('used', state.deadPiles[0].length === 0);
          s1.classList.toggle('used', state.deadPiles[1].length === 0);
        }

        // M√£os Oponentes
        renderOpponentHands();

        // Minha M√£o
        renderHand();

        // Jogos
        renderMelds();

        // Bot√µes
        const myTurn = !state.finished && state.currentPlayer === myPlayerIndex;

        // üîî Vibra quando passa a ser a minha vez
        if (myTurn && !lastMyTurn && navigator.vibrate) {
          navigator.vibrate([150, 80, 150]); // vibra, pausa, vibra
        }
        lastMyTurn = myTurn;

        document.getElementById('drawStockBtn').style.pointerEvents = myTurn && !state.hasDrawnThisTurn ? 'auto' : 'none';

        document.getElementById('drawStockBtn').style.pointerEvents = myTurn && !state.hasDrawnThisTurn ? 'auto' : 'none';
        document.getElementById('drawStockBtn').style.opacity = myTurn && !state.hasDrawnThisTurn ? '1' : '0.5';

        document.getElementById('drawDiscardBtn').style.pointerEvents = myTurn && !state.hasDrawnThisTurn && state.discard.length ? 'auto' : 'none';
        document.getElementById('drawDiscardBtn').style.opacity = myTurn && !state.hasDrawnThisTurn && state.discard.length ? '1' : '0.5';

        // document.getElementById('meldBtn').disagbled = !myTurn || !state.hasDrawnThisTurn;
        document.getElementById('meldBtn').disabled = !myTurn || !state.hasDrawnThisTurn;

        document.getElementById('discardBtn').disabled = !myTurn || !state.hasDrawnThisTurn;

        const teamId = currentPlayer().teamId;
        const taken = state.deadChunksTaken?.[teamId] ?? 0;
        const max = state.deadChunksMax?.[teamId] ?? 1;
        document.getElementById('takeDeadBtn').disabled = !myTurn || taken >= max;
        document.getElementById('endGameBtn').disabled = false;

        if (state.finished) renderScores(computeScores(), state.winnerTeamId);
      }

      function renderHand() {
        const container = document.querySelector('#handContainer .cards-row');
        container.innerHTML = '';
        const me = state.players[myPlayerIndex];
        document.getElementById('handCountLabel').textContent = me.hand.length;
        me.hand.forEach((card, idx) => {
          ensureCardId(card);
          const div = document.createElement('div');
          div.dataset.cardId = card.id;
          div.className = 'carta ' + (card.joker ? 'joker-card' : card.suit === '‚ô•' || card.suit === '‚ô¶' ? 'hearts' : 'spades');
          if (card.id === lastBoughtCardId) {
            div.classList.add('just-bought');
            requestAnimationFrame(() => {
              div.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
            });
          }

          div.innerHTML = card.joker ? `<div class="carta-canto">JOKER</div><div class="carta-icone">‚òÖ</div>` : `<div class="carta-canto">${card.rank}<br>${card.suit}</div><div class="carta-icone">${card.suit}</div>`;
          if (selectedHandIndexes.has(idx)) div.classList.add('selected');
          div.onclick = () => {
            if (state.currentPlayer !== myPlayerIndex) return;
            if (selectedHandIndexes.has(idx)) selectedHandIndexes.delete(idx);
            else selectedHandIndexes.add(idx);
            renderHand();
          };
          container.appendChild(div);
        });
      }

      function seatForPlayer(pid) {
        const total = state.players.length;
        if (pid === myPlayerIndex) return 'self';

        const others = [];
        for (let i = 1; i < total; i++) others.push((myPlayerIndex + i) % total);

        const seats = { top: null, left: null, right: null };
        if (total === 2) seats.top = others[0];
        else if (total === 3) {
          seats.right = others[0];
          seats.left = others[1];
        } else {
          // 4
          seats.right = others[0];
          seats.top = others[1];
          seats.left = others[2];
        }

        if (seats.top === pid) return 'top';
        if (seats.left === pid) return 'left';
        if (seats.right === pid) return 'right';
        return null;
      }

      function fallbackSeatRect(seat) {
        const vw = window.innerWidth;
        const vh = window.innerHeight;

        if (seat === 'top') return { left: vw * 0.5 - 20, top: 40, width: 40, height: 60 };
        if (seat === 'left') return { left: 12, top: vh * 0.5 - 30, width: 40, height: 60 };
        if (seat === 'right') return { left: vw - 52, top: vh * 0.5 - 30, width: 40, height: 60 };

        return null;
      }

      function opponentAnchorRect(pid) {
        const seat = seatForPlayer(pid);

        if (seat === 'top') return getOpponentAnchorRectById('opponentTop', 'top');
        if (seat === 'left') return getOpponentAnchorRectById('opponentLeft', 'left');
        if (seat === 'right') return getOpponentAnchorRectById('opponentRight', 'right');

        return null;
      }

      function getOpponentAnchorRectById(rootId, seatFallback) {
        const root = document.getElementById(rootId);
        if (!root) return fallbackSeatRect(seatFallback);

        // tenta primeiro no container das cartas
        const cards = root.querySelector('.opponent-cards');
        const r1 = cards ? cards.getBoundingClientRect() : null;

        if (r1 && r1.width > 0 && r1.height > 0) {
          return {
            left: r1.left + r1.width * 0.5 - 20,
            top: r1.top + r1.height * 0.5 - 30,
            width: 40,
            height: 60,
          };
        }

        // fallback: usa o root todo (label + √°rea)
        const r2 = root.getBoundingClientRect();
        if (r2 && r2.width > 0 && r2.height > 0) {
          return {
            left: r2.left + r2.width * 0.5 - 20,
            top: r2.top + r2.height * 0.5 - 30,
            width: 40,
            height: 60,
          };
        }

        // fallback final (coordenada fixa na tela)
        return fallbackSeatRect(seatFallback);
      }

      // ==========================
      // MODO TESTE / DEBUG 1
      // ==========================
      window.debugScoreExample = function () {
        // sempre testar como Jogador 1
        myPlayerIndex = 0;

        const C = (rank, suit, joker = false) => ({ rank, suit, joker });

        // monta um state COMPLETO s√≥ em mem√≥ria, sem Firebase
        state = {
          mode: '1x1',
          variant: 'fechado',
          players: [
            { id: 0, name: 'Jogador 1', teamId: 0, hand: [] },
            { id: 1, name: 'Jogador 2', teamId: 1, hand: [] },
          ],
          teams: [
            { id: 0, name: 'Time 1', playerIndexes: [0], melds: [] },
            { id: 1, name: 'Time 2', playerIndexes: [1], melds: [] },
          ],
          currentPlayer: 0,
          stock: [],
          discard: [],
          deadPiles: [[], []],
          deadChunksTaken: [1, 1],
          deadChunksMax: [1, 1],
          hasDrawnThisTurn: true,
          finished: true, // j√° marca como fim de jogo
          winnerTeamId: 0, // vit√≥ria da equipe 1
          j2ConsecutiveTurns: 0,
          requiredDiscardCard: null,
        };

        const t1 = state.teams[0].melds;
        const t2 = state.teams[1].melds;

        // ---------- TIME 1 ----------

        // 1) Canastra REAL (2 ... A do mesmo naipe, sem coringa)
        t1.push([C('A', '‚ô£'), C('2', '‚ô£'), C('3', '‚ô£'), C('4', '‚ô£'), C('5', '‚ô£'), C('6', '‚ô£'), C('7', '‚ô£'), C('8', '‚ô£'), C('9', '‚ô£'), C('10', '‚ô£'), C('J', '‚ô£'), C('Q', '‚ô£'), C('K', '‚ô£')]);

        // 2) Canastra √ÅS A √ÅS (come√ßa e termina com √Ås)
        t1.push([C('A', '‚ô¶'), C('2', '‚ô¶'), C('3', '‚ô¶'), C('4', '‚ô¶'), C('5', '‚ô¶'), C('6', '‚ô¶'), C('7', '‚ô¶'), C('8', '‚ô¶'), C('9', '‚ô¶'), C('10', '‚ô¶'), C('J', '‚ô¶'), C('Q', '‚ô¶'), C('K', '‚ô¶'), C('A', '‚ô¶')]);

        // 3) Canastra LIMPA (sem coringa, sem √Ås no topo)
        t1.push([C('4', '‚ô•'), C('5', '‚ô•'), C('6', '‚ô•'), C('7', '‚ô•'), C('8', '‚ô•'), C('9', '‚ô•'), C('10', '‚ô•')]);

        // ---------- TIME 2 ----------

        // 4) Canastra SUJA (com coringa no meio)
        t2.push([C('5', '‚ô†'), C('6', '‚ô†'), C('7', '‚ô†'), C('JOKER', '‚òÖ', true), C('9', '‚ô†'), C('10', '‚ô†'), C('J', '‚ô†')]);

        // ningu√©m com carta na m√£o
        state.players[0].hand = [];
        state.players[1].hand = [];

        // limpa sele√ß√µes
        selectedHandIndexes.clear();
        selectedMeldTarget = null;

        // renderiza tudo e j√° for√ßa o placar
        renderAll();
        const scores = computeScores();
        renderScores(scores, state.winnerTeamId);

        showMessage('DEBUG: exemplo com canastra real, √Ås a √Ås, limpa e suja.');
      };

      // =====================================================
      // MODO TESTE 2: playground para sequ√™ncias e coringas
      // =====================================================
      window.debugSequenciasCoringas = function () {
        // garante que voc√™ √© o Jogador 1
        myPlayerIndex = 0;

        const C = (rank, suit, joker = false) => ({ rank, suit, joker });

        // state completo, mas jogo N√ÉO terminado
        state = {
          mode: '1x1',
          variant: 'fechado',
          players: [
            { id: 0, name: 'Jogador 1', teamId: 0, hand: [] },
            { id: 1, name: 'Jogador 2', teamId: 1, hand: [] },
          ],
          teams: [
            { id: 0, name: 'Time 1', playerIndexes: [0], melds: [] },
            { id: 1, name: 'Time 2', playerIndexes: [1], melds: [] },
          ],
          currentPlayer: 0,
          stock: [], // pode deixar vazio, foco √© mexer nos jogos
          discard: [], // se quiser testar compra do descarte, p√µe carta aqui
          deadPiles: [[], []],
          deadChunksTaken: [0, 0],
          deadChunksMax: [1, 1],
          hasDrawnThisTurn: true, // j√° ‚Äúcomprou‚Äù, pode s√≥ baixar / mexer jogo
          finished: false, // N√ÉO terminou
          winnerTeamId: null,
          j2ConsecutiveTurns: 0,
          requiredDiscardCard: null,
        };

        const t1 = state.teams[0].melds;
        const t2 = state.teams[1].melds;

        // ---------------- TIME 1 (seus jogos) ----------------

        // 1) A‚ô£ 2‚ô£ 3‚ô£ 4‚ô£ 5‚ô£ 6‚ô£ 7‚ô£  -> 2 N√ÉO √© coringa aqui (A-2-3)
        t1.push([C('A', '‚ô£'), C('2', '‚ô£'), C('3', '‚ô£'), C('4', '‚ô£'), C('5', '‚ô£'), C('6', '‚ô£'), C('7', '‚ô£')]);

        // 2) A‚ô• JOKER 3‚ô• 4‚ô• 5‚ô• -> buraco A‚Äì3 preenchido por coringa (suja)
        t1.push([C('A', '‚ô•'), C('JOKER', '‚òÖ', true), C('3', '‚ô•'), C('4', '‚ô•'), C('5', '‚ô•')]);

        // 3) 8‚ô¶ 9‚ô¶ JOKER J‚ô¶ Q‚ô¶ -> coringa no meio de sequ√™ncia normal
        t1.push([C('8', '‚ô¶'), C('9', '‚ô¶'), C('JOKER', '‚òÖ', true), C('J', '‚ô¶'), C('Q', '‚ô¶')]);

        // 4) Q‚ô† K‚ô† A‚ô† -> sequ√™ncia com √Ås alto
        t1.push([C('Q', '‚ô†'), C('K', '‚ô†'), C('A', '‚ô†')]);

        // ---------------- TIME 2 (refer√™ncia) ----------------

        // 5) 4‚ô† 5‚ô† 6‚ô† 7‚ô† 8‚ô† 9‚ô† 10‚ô† -> canastra limpa simples pra comparar
        t2.push([C('4', '‚ô†'), C('5', '‚ô†'), C('6', '‚ô†'), C('7', '‚ô†'), C('8', '‚ô†'), C('9', '‚ô†'), C('10', '‚ô†')]);

        // 6) A‚ô¶ 2‚ô¶ 3‚ô¶ 4‚ô¶ 5‚ô¶ 6‚ô¶ 7‚ô¶ 8‚ô¶ 9‚ô¶ 10‚ô¶
        t2.push([C('A', '‚ô¶'), C('2', '‚ô¶'), C('3', '‚ô¶'), C('4', '‚ô¶'), C('5', '‚ô¶'), C('6', '‚ô¶'), C('7', '‚ô¶'), C('8', '‚ô¶'), C('9', '‚ô¶'), C('10', '‚ô¶')]);

        // ---------------- CARTAS NA M√ÉO ----------------

        // Sua m√£o: v√°rios 2 e coringas pra voc√™ brincar de mover
        state.players[0].hand = [C('2', '‚ô•'), C('2', '‚ô†'), C('2', '‚ô¶'), C('JOKER', '‚òÖ', true), C('5', '‚ô£'), C('K', '‚ô¶'), C('A', '‚ô£')];

        // m√£o do jogador 2 s√≥ pra n√£o ficar vazia
        state.players[1].hand = [C('7', '‚ô†'), C('8', '‚ô†'), C('9', '‚ô†')];

        // limpa sele√ß√µes
        selectedHandIndexes.clear();
        selectedMeldTarget = null;

        renderAll();
        showMessage('DEBUG: playground de sequ√™ncias e coringas carregado.');
      };

      function renderOpponentHands() {
        const top = document.getElementById('opponentTop');
        top.innerHTML = '';
        const left = document.getElementById('opponentLeft');
        left.innerHTML = '';
        const right = document.getElementById('opponentRight');
        right.innerHTML = '';

        const total = state.players.length;
        const seats = { top: null, left: null, right: null };
        const others = [];
        for (let i = 1; i < total; i++) others.push((myPlayerIndex + i) % total);

        if (total === 2) seats.top = others[0];
        else if (total === 3) {
          seats.right = others[0];
          seats.left = others[1];
        } else {
          seats.right = others[0];
          seats.top = others[1];
          seats.left = others[2];
        }

        [
          { idx: seats.top, el: top },
          { idx: seats.left, el: left },
          { idx: seats.right, el: right },
        ].forEach((obj) => {
          if (obj.idx === null) return;
          const p = state.players[obj.idx];
          const label = document.createElement('div');
          label.className = 'opponent-label';
          label.textContent = `${p.name} (${p.hand.length})`;
          obj.el.appendChild(label);

          const cardsDiv = document.createElement('div');
          cardsDiv.className = 'opponent-cards';
          const count = Math.min(p.hand.length, 12);
          for (let i = 0; i < count; i++) {
            const cdata = p.hand[i]; // existe no state hoje
            const c = document.createElement('div');
            c.className = 'opponent-card-back ' + (cdata?.back === 'blue' ? 'back-blue' : 'back-red');
            cardsDiv.appendChild(c);
          }

          obj.el.appendChild(cardsDiv);
        });
      }

      function renderMelds() {
        const m1 = document.getElementById('meldsP1');
        m1.innerHTML = '';
        const m2 = document.getElementById('meldsP2');
        m2.innerHTML = '';
        let s1 = 0,
          s2 = 0;
        state.teams.forEach((t, i) => {
          const info = computeTeamMeldScore(t);
          if (i === 0) s1 = info.total;
          else s2 = info.total;
          const target = i === 0 ? m1 : m2;
          t.melds.forEach((meld, midx) => {
            const div = document.createElement('div');
            div.className = 'meld-line';
            const key = t.id + ':' + midx;
            div.dataset.meldKey = key;
            if (selectedMeldTarget === key) div.classList.add('selected-meld');

            const row = document.createElement('div');
            row.className = 'meld-line-cards';
            const mInfo = classifyMeldForUi(meld);

            meld.forEach((c, cidx) => {
              if (mInfo.kind !== 'simple' && cidx === meld.length - 1) return;
              const minic = document.createElement('div');
              minic.className = 'carta mini ' + (c.joker ? 'joker-card' : c.suit === '‚ô•' || c.suit === '‚ô¶' ? 'hearts' : 'spades');
              minic.innerHTML = c.joker ? `<div class="carta-canto">‚òÖ</div>` : `<div class="carta-canto">${c.rank}${c.suit}</div>`;
              row.appendChild(minic);
            });

            if (mInfo.kind !== 'simple') {
              const last = meld[meld.length - 1];
              const closed = document.createElement('div');
              closed.className = 'carta mini canastra-fechada ' + (last.joker ? 'joker-card' : last.suit === '‚ô•' || last.suit === '‚ô¶' ? 'hearts' : 'spades');
              closed.innerHTML = last.joker ? `<div class="carta-canto">‚òÖ</div>` : `<div class="carta-canto">${last.rank}${last.suit}</div>`;
              row.appendChild(closed);
            }

            const meta = document.createElement('div');
            meta.className = 'meld-meta';
            meta.innerHTML = mInfo.base + (mInfo.tag ? ` <span class="meld-tag ${mInfo.tag.cls}">${mInfo.tag.text}</span>` : '');

            div.appendChild(row);
            div.appendChild(meta);
            div.onclick = () => {
              selectedMeldTarget = selectedMeldTarget === key ? null : key;
              showMessage(selectedMeldTarget ? 'Jogo selecionado.' : 'Sele√ß√£o limpa.');
              renderMelds();
            };
            target.appendChild(div);
          });
        });
        document.getElementById('scoreTeam1').textContent = s1;
        document.getElementById('scoreTeam2').textContent = s2;
      }

      function renderScores(scores, winner) {
        document.getElementById('scoreSection').style.display = 'flex';
        const board = document.getElementById('scoreBoard');
        board.innerHTML = '';
        scores.sort((a, b) => b.score - a.score);
        scores.forEach((s) => {
          board.innerHTML += `<div style="margin-bottom:8px; border-bottom:1px solid #333; padding-bottom:4px;">
              <strong style="color:${s.team.id === winner ? '#facc15' : '#fff'}">${s.team.name}</strong>: ${s.score} pts
              <div style="font-size:10px; color:#aaa;">M√£o: -${s.handPenalty} | Jogos: +${s.meldPoints} | B√¥nus: +${s.sujaBonus + s.limpaBonus + s.realBonus + s.asasBonus}</div>
            </div>`;
        });
      }

      function showMessage(msg) {
        document.getElementById('message').textContent = msg;
      }

      function seatElForPlayer(pid) {
        if (pid === myPlayerIndex) return document.getElementById('handContainer');

        const total = state.players.length;
        const others = [];
        for (let i = 1; i < total; i++) others.push((myPlayerIndex + i) % total);

        // mesmo mapeamento do renderOpponentHands()
        if (total === 2) return pid === others[0] ? document.getElementById('opponentTop') : null;

        if (total === 3) {
          if (pid === others[0]) return document.getElementById('opponentRight');
          if (pid === others[1]) return document.getElementById('opponentLeft');
          return null;
        }

        if (pid === others[0]) return document.getElementById('opponentRight');
        if (pid === others[1]) return document.getElementById('opponentTop');
        if (pid === others[2]) return document.getElementById('opponentLeft');
        return null;
      }

      function seatPointRect(pid) {
        const el = seatElForPlayer(pid);
        if (!el) return null;
        const r = el.getBoundingClientRect();
        // um ‚Äúponto‚Äù de onde sai/entra carta no seat
        return { left: r.left + r.width * 0.5 - 20, top: r.top + 18, width: 40, height: 60 };
      }

      async function playRemoteAction(a) {
        if (!state || !a) return;

        const stockEl = document.querySelector('#drawStockBtn .pile-card');
        const discardEl = document.getElementById('discardFace');
        const dead0El = document.getElementById('mortoSlot0');
        const dead1El = document.getElementById('mortoSlot1');

        const stockRect = stockEl ? getRect(stockEl) : null;
        const discardRect = discardEl ? getRect(discardEl) : null;

        const handRect = opponentAnchorRect(a.playerId);
        if (!handRect) return;

        const fallbackCard = a.card || { rank: '‚òÖ', suit: '‚òÖ', joker: true, id: `rf_${Date.now()}` };

        // helper pra ‚Äúcair‚Äù v√°rias com offsets
        const dropRects = (baseRect, count) => {
          const out = [];
          for (let i = 0; i < count; i++) {
            out.push({ ...baseRect, left: baseRect.left - i * 10, top: baseRect.top + i * 2 });
          }
          return out;
        };

        if (a.type === 'drawStock') {
          if (stockRect) await flyRectToRect(fallbackCard, stockRect, handRect, 'back');
          impactAtRect(handRect); // ‚úÖ era toRect inexistente
          return;
        }

        if (a.type === 'drawDiscard') {
          if (discardRect) await flyRectToRect(fallbackCard, discardRect, handRect, 'front');
          impactAtRect(handRect); // ‚úÖ era toRect inexistente
          return;
        }

        if (a.type === 'discard') {
          if (discardRect) await flyRectToRect(fallbackCard, handRect, discardRect, 'front');
          impactAtRect(discardRect); // ‚úÖ fa√≠sca onde caiu (no lixo)
          return;
        }

        if (a.type === 'takeDead') {
          const fromEl = a.deadIndex === 1 || a.teamId === 1 ? dead1El : dead0El;
          const fromRect = fromEl ? getRect(fromEl) : null;
          if (fromRect) await flyRectToRect(fallbackCard, fromRect, handRect, 'back');
          impactAtRect(handRect); // ‚úÖ
          return;
        }

        if (a.type === 'meldNew') {
          // ‚úÖ tenta cair no MELD CERTO se veio meldIndex
          let base = null;

          if (a.meldIndex != null && a.teamId != null) {
            const key = `${a.teamId}:${a.meldIndex}`;
            base = meldDropRect(key, 0); // usa a trilha do jogo
          }

          // fallback se ainda n√£o existir no DOM (raro)
          if (!base) {
            const container = document.getElementById((a.teamId ?? 0) === 0 ? 'meldsP1' : 'meldsP2');
            if (!container) return;
            const tr = container.getBoundingClientRect();
            base = { left: tr.left + tr.width - 30, top: tr.top + 10, width: 22, height: 30 };
          }

          const cards = a.cards && a.cards.length ? a.cards : [fallbackCard];
          const targets = dropRects(base, cards.length);

          // ‚úÖ ao mesmo tempo + fa√≠sca por carta
          await Promise.all(
            cards.map((c, i) => {
              c.id ||= `rm_${Date.now()}_${i}`;
              const toRect = targets[i];
              return flyRectToRect(c, handRect, toRect, 'front').then(() => impactAtRect(toRect));
            })
          );

          return;
        }

        if (a.type === 'meldExtend') {
          if (a.meldIndex == null || a.teamId == null) return;

          const key = `${a.teamId}:${a.meldIndex}`;
          const base = meldDropRect(key, 0);
          if (!base) return;

          const cards = a.cards && a.cards.length ? a.cards : [fallbackCard];
          const targets = dropRects(base, cards.length);

          // ‚úÖ ao mesmo tempo + fa√≠sca
          await Promise.all(
            cards.map((c, i) => {
              c.id ||= `re_${Date.now()}_${i}`;
              const toRect = targets[i];
              return flyRectToRect(c, handRect, toRect, 'front').then(() => impactAtRect(toRect));
            })
          );

          return;
        }
      }

      onSnapshot(gameRef, async (snap) => {
        if (!snap.exists()) {
          state = null;
          selectedHandIndexes.clear();
          document.getElementById('configSection').style.display = 'block';
          document.getElementById('gameSection').style.display = 'none';
          return;
        }

        const newState = JSON.parse(snap.data().stateJson);
        state = newState;

        selectedHandIndexes.clear();
        document.getElementById('configSection').style.display = 'none';
        document.getElementById('gameSection').style.display = 'flex';

        renderAll();
        startTurnTimerIfNeeded();

        const a = state.lastAction;
        if (!a || a.id === lastSeenActionId) return;

        lastSeenActionId = a.id;

        // evita ‚Äúre-animar‚Äù no pr√≥prio client (porque voc√™ j√° animou localmente)
        if (a.id === ignoreOwnActionId) {
          ignoreOwnActionId = null;
          return;
        }

        // anima pros outros
        await playRemoteAction(a);
      });

      document.getElementById('startBtn').onclick = () => {
        startGame(
          document.getElementById('modeSelect').value,
          [document.getElementById('p1Name').value, document.getElementById('p2Name').value, document.getElementById('p3Name').value, document.getElementById('p4Name').value],
          document.getElementById('variantSelect').value
        );
      };

      document.getElementById('localPlayerSelect').onchange = (e) => {
        myPlayerIndex = parseInt(e.target.value);
        if (state) renderAll();
      };
      document.getElementById('drawStockBtn').onclick = drawFromStock;
      document.getElementById('drawDiscardBtn').onclick = drawFromDiscard;
      document.getElementById('meldBtn').onclick = makeMeldFromSelection;
      document.getElementById('discardBtn').onclick = discardSelectedCard;
      document.getElementById('takeDeadBtn').onclick = takeDead;
      document.getElementById('endGameBtn').onclick = () => deleteDoc(gameRef);
      document.getElementById('closeScoreBtn').onclick = () => (document.getElementById('scoreSection').style.display = 'none');
    </script>
  </body>
</html>
